<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    <title>Shape Expressions Language 2.0</title>
    <!-- link rel="stylesheet" href="css/wgio.min.css"/ ask Iovka -->
    <link rel="stylesheet" href="local.css"/>

    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            async="async" class='remove'></script>
    <!-- script src='../primer/respec-w3c-common.js' async class='remove'></script -->
    <script src="jquery-2.1.4.min.js" type="text/javascript"></script>

    <script class='remove'>
      var respecConfig = {
      specStatus:     "CG-DRAFT",
      shortName:      "shex-semantics",
      prevVersion:    "https://www.w3.org/Submission/2014/SUBM-shex-defn-20140602/",
      previousPublishDate:  "2014-06-02",
      previousMaturity:"Member-SUBM",
      testSuiteURI:   "https://github.com/shexSpec/shexTest",
      issueBase:      "https://github.com/shexSpec/shex/issues",
      githubAPI:      "https://api.github.com/repos/shexSpec/shex",
      editors: [
        { name:       "Eric Prud'hommeaux",
          url:        "http://www.w3.org/People/Eric/",
          company:    "W3C/MIT",
          companyURL: "http://www.w3.org/" },
        { name:       "Iovka Boneva",
          url:        "http://cristal.univ-lille.fr/~boneva/",
          company:    "University of Lille",
          companyURL: "http://www.univ-lille1.fr/" },
        { name:       "Jose Labra Gayo",
          url:        "http://di002.edv.uniovi.es/~labra/",
          company:    "University of Oviedo",
          companyURL: "http://www.uniovi.es/" },
        { name:       "Gregg Kellogg",
          url:        "http://greggkellogg.net/",
          company:    "Spec-Ops",
          companyURL: "https://spec-ops.io/",
          w3cid:      "44770" },
      ],
      wg:           "Shape Expressions Community Group",
      wgURI:        "https://shexspec.github.io",
      wgPublicList: "public-shex",
      wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",

      bugTracker:             {
        open: "https://github.com/shexSpec/shex/issues",
        new:  "https://github.com/shexSpec/shex/issues/new"
      },

      otherLinks: [{
        key: "Version control",
        data: [{
          value: "Github Repository",
          href: "https://github.com/shexSpec/spec"
        }]
      }],
      };
    </script>

    <script type="text/javascript" src="scripts.js"></script>
  </head>
  
  <body>
    <section id="abstract">
      <p>
        The Shape Expressions (ShEx) language describes RDF nodes and graph structures.
        A <m>node constraint</m> describes an RDF node (IRI, blank node or literal) and a <m>shape</m> describes the triples involving nodes in an RDF graph.
        These descriptions identify predicates and their associated cardinalities and datatypes.
        ShEx shapes can be used to communicate data structures associated with some process or interface, generate or validate data, or drive user interfaces.
      </p>
      <p>
        This document defines the ShEx language.
        See the <a href="../primer/index.html">Shape Expressions Primer</a> for a non-normative description of ShEx.
      </p>
    </section>

    <section id="sotd">
  <p>This document has been developed by the
    <a href="https://www.w3.org/community/shex/">Shape Expressions Community Group</a>.
    The specification has undergone
    significant development since the 1.0 version.</p>
    </section>

    <section id="status">
      <p>
        The Shape Expressions language is expected to remain stable with the exception of:
      </p>
      <ul>
        <li>addition of a UNIQUE function</li>
        <li>addition of a mechanism for labeling productions</li>
      </ul>
    </section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        The Shape Expressions (ShEx) language provides a structural schema for RDF data.
        This can be used to document APIs or datasets, aid in development of API-conformant messages, minimize defensive programming, guide user interfaces, or anything else that involves a machine-readable description of data organization and typing requirements.
      </p>
      <p>
        ShEx describes RDF graph structures as sets of potentially connected <code>Shapes</code>.
        These constrain the triples involving nodes in an RDF graph.
        <code>Node Constraints</code> constrain RDF nodes by constraining their node kind (IRI, blank node or Literal), enumerating permissible values in value sets, specifying their datatype, and constraining value ranges of Literals.
        Additionally, they constrain lexical forms of Literals, IRIs and labeled blank nodes.
        Shape Expressions schemas share blank nodes with the constrained RDF graphs in the same way that graphs in <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-dataset">RDF datasets</a>[[!rdf11-concepts]] share blank nodes.
      </p>
      <p>
        ShEx can be represented in JSON structures (ShExJ) or a compact syntax (ShExC).
        The compact syntax is intended for human consumption; the JSON structure for machine processing.
        This document defines ShEx in terms of ShExJ and includes a <a href="#shexc">section on the ShEx Compact Syntax (ShEx)</a>.
      </p>
    </section>

    <section id="notation">
      <h2>Notation</h2>
      <p>
        <!-- @@Labra: I would probably add a paragraph saying something about the abstract syntax so you can later talk about JSON... -->
        <!-- @@ericP: I changed "the" to "an" below in hopes that suffices. I don't want to define an abstract syntax in addition to ShExJ if we can avoid it. -->
        The JSON[[!rfc4627]] Syntax serves as a serializable proxy for an abstract syntax.
        This specification uses a simple grammar to describe the set of JSON documents that can be interpreted as a ShEx schema.
      </p>
      <ul>
        <li>Typed data structures are represented as JSON objects:
        <span class="shexj">typeName { <a href="https://tools.ietf.org/html/rfc4627#section-2.2">member*</a> }</span><br/>
        <a href="https://tools.ietf.org/html/rfc4627#section-2.2">RFC4627 Section 2.2</a> provides syntactic constraints for JSON ‚Äî this grammar constrains those to valid ShExJ constructs. 
        </li>
        <li><code>typeName</code> is the name of the typed data structure.
        Types are referenced in the definitions of object members and in the definitions of the semantics for those data structures.</li>
        <li><code>member*</code> is a list of zero or more terminals or references to other typeExpressions.</li>
        <li><code>Terminals</code> are JSON strings and are indicated by all-caps, e.g.  <a class="trmref" href="#dfn-IRI">IRI</a>.
          For brevity, RDF nodes are represented as JSON strings composed as:
        <ul>
          <li><code>IRI</code>: the lexical form of the IRI, e.g. <code class="json">"http://example.org/resource"</code></li>
          <li><code>BNODE</code>: the concatenation of "<code>_:</code>" and a blank node label, e.g. <code class="json">"_:blank3"</code></li>
          <li><code>LITERAL</code>: the concatenation of a U+0022 ('<code>"</code>'), the lexical form of the literal, U+0022, and the first matching of:
          <ul>
            <li>literal with type <code>http://www.w3.org/2001/XMLSchema#string</code>: empty string, e.g. <code class="json">"abc"</code>.</li>
            <li>language tagged literal: U+0040 ('<code>@</code>') and the language tag, e.g. <code class="json">"\"hello world\"@en-US"</code></li>
            <li>datatyped literal: U+005E U+005E ('<code>^^</code>') and the lexical form of the datatype URI, e.g. <code class="json">"\"123\"^^http://www.w3.org/2001/XMLSchema#integer"</code></li>
          </ul></li>
        </ul>
        </li>
        <li>A <code>typeExpression</code> is one of:
        <ul>
          <li><code>typeName</code> ‚Äî an object of corresponding type</li>
          <li><code>array</code>: <span class="shexj">[ typeExpression+ ]</span>‚Äî an array of one or more JSON values matching the typeExpression.</li>
          <li><code>choice</code>: <span class="shexj">typeExpression1 | typeExpression2 | ‚Ä¶</span>‚Äî a choice between two or more typeExressions.</li>
        </ul>
        </li>
        <li>Cardinalities are represented as by the strings <code>?</code>, <code>+</code>, <code>*</code> per <a href="https://www.w3.org/TR/xml/#sec-notation">XML notation</a> or <code>{m,}</code> to indicate a that at least <code>m</code> elements are required.</li>
      </ul>

      <p>
        Schemas with the marker "ùôÖ/c" in the corner can be converted between the JSON representation and the compact syntax by clicking the marker.
        Pressing "j" or "c" converts all such examples to the JSON or compact form.
        In the JSON notation,
      </p>

      <div class="shexj">
        <pre><a href="#dfn-Schema" class="obj">Schema</a> { <span class="param">startActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">start</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">shapes</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>+]? }</pre>
      </div>
      <p>
        signifies that a <code>Schema</code> has three optional components called <code class="param">startActs</code>, <code class="param">start</code> and <code class="param">shapes</code>:
      </p>
      <ul>
        <li><code class="param">startActs</code> is a list of <a class="objref" href="#dfn-SemAct">SemAct</a>.<!-- @@Labra: Maybe you can say here that lists are represented by square brackets ? --></li>
        <li><code class="param">start</code> is a <a class="objref" href="#dfn-shapeExpr">shapeExpr</a>.</li>
        <li><code class="param">shapes</code> is an array of <a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>.</li>
      </ul>

      <div class="shexj">
        <pre><a href="#dfn-shapeExpr" class="nob">shapeExpr</a> = <a class="objref" href="#dfn-ShapeOr">ShapeOr</a> | <a class="objref" href="#dfn-ShapeAnd">ShapeAnd</a> | <a class="objref" href="#dfn-ShapeNot">ShapeNot</a>
            | <a class="objref" href="#dfn-NodeConstraint">NodeConstraint</a> | <a class="objref" href="#dfn-Shape">Shape</a> | <a class="objref" href="#dfn-shapeRef">shapeRef</a> | <a class="objref" href="#dfn-ShapeExternal">ShapeExternal</a> ;</pre>
      </div>
      <p>
        signifies that a <code>shapeExpr</code> is one of seven object types: <a class="objref .shexj" href="#dfn-ShapeOr">ShapeOr</a> | <a class="objref" href="#dfn-ShapeAnd">ShapeAnd</a> | ‚Ä¶.
      </p>

      <div class="shexj">
        <pre><a href="#dfn-NodeConstraint" class="obj">NodeConstraint</a> { <span class="param">nodeKind</span>:(<span class="literal">"iri"</span> | <span class="literal">"bnode"</span> | <span class="literal">"nonliteral"</span> | <span class="literal">"literal"</span>)? <a class="nobref" href="#dfn-xsFacet">xsFacet</a>* }
       <a href="#dfn-xsFacet" class="nob">xsFacet</a> = <a class="nobref" href="#dfn-stringFacet">stringFacet</a> | <a class="nobref" href="#dfn-numericFacet">numericFacet</a> ;</pre>
      </div>
      <p>
        signifies that a <code>NodeConstraint</code> has a <code class="param">nodeKind</code> of one of the four literals followed by any number of <a class="objref .shexj" href="#dfn-xsFacet">xsFacet</a> and an <a class="objref .shexj" href="#dfn-xsFacet">xsFacet</a> is either a <a class="objref .shexj" href="#dfn-stringFacet">stringFacet</a> or a <a class="objref .shexj" href="#dfn-numericFacet">numericFacet</a>.
      </p>

      <section id="references">
        <h3>References</h3>
        <p>
          ShExJ is a dialect of JSON-LD[[!JSON-LD]] and the member <code>id</code> is used as a <a href="https://www.w3.org/TR/json-ld/#node-identifiers">node identifier</a>.
          An object may be represented inline or referenced by its <code>id</code> which may be either a blank node or an IRI.
        </p>
        <div class="shexj">
          <pre> <a href="#dfn-shapeRef" class="nob">shapeRef</a> = <a class="objref" href="#dfn-IRI">IRI</a> | <a class="objref" href="#dfn-BNODE">BNODE</a> ;</pre>
        </div>
        <p>
          An object with a circular reference must be referenced by id.
          This example uses a nested shape reference on a value expression (<a href="#dfn-TripleConstraint">defined below</a>).
        </p>
        <div class="json">
          <pre class="json">{ "type": "Schema", "shapes": {
      "http://schema.example/IssueShape": {
      "type": "Shape", "expression": {
        "type": "TripleConstraint", "predicate": "http://schema.example/related",
        "valueExpr": "http://schema.example/IssueShape", min: 0 } } } }</pre>
        </div>
      </section>  
      <section id="style">
        <h3>Document style</h3>
        <p>
          JSON examples are rendered in a <span class="json">.json</span> CSS style.
          Partial examples include ranges in a <span class="comment">.comment</span> CSS style to indicate text which would be substituted in a complete example.
          For example  <span class="json">{ "type": "ShapeAnd", "shapeExprs": [ <span class="comment">SE<sub>1</sub></span>, <span class="comment">‚Ä¶</span> ] }</span> indicates that both <span class="comment">SE<sub>1</sub></span> and <span class="comment">‚Ä¶</span> would be substituted in a complete example.
        </p>
      <!--div class="issue">
        <p id="json-triples">
          When stable, consider switching to the rdfjs task force's <a href="https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md#term">JSON representation</a> i.e.
        </p>
        <ul>
          <li>IRI: <code class="json">{ "termType": "NamedNode", "value": "http://example.org/resource" }</code></li>
          <li>blank node: <code class="json">{ "termType": "BlankNode", "value": "blank3" }</code></li>
          <li>literal:
          <ul>
            <li>literal with type <code>http://www.w3.org/2001/XMLSchema#</code>: <code class="json">{ "termType": "Literal", "value": "abc" }</code></li>
            <li>language tagged literal: <code class="json">{ "termType": "Literal", "value": "hello world", "language": "en-us", "datatype": "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" }</code></li>
            <li>datatyped literal: <code class="json">{ "termType": "Literal", "value": "123", "language": "", "datatype": "http://www.w3.org/1999/02/22-rdf-syntax-ns#integer" }</code></li>
          </ul></li>
        </ul>
      </div-->
      </section>
      <section id="graphAccess">
        <h3>Graph access</h3>
      <p>
        The validation process defined in this document relies on matching triple patterns in the form <code>(subject, predicate, object)</code> where each position may be supplied by a constant, a previously defined term, or the underscore "<code>_</code>", which represents a previously undefined element or wildcard.
        This corresponds to a <a href="http://www.w3.org/TR/sparql11-query/#defn_TriplePattern">SPARQL Triple Pattern</a> where each "_" is replaced by a unique blank node.
        Matching such a triple pattern against a graph is defined by <a href="http://www.w3.org/TR/sparql11-query/#BGPsparql">SPARQL Basic Graph Pattern Matching</a> (BFP) with a BGP containing only that triple pattern.
      </p>
      </section>
      <!-- button id="toggleRDF">Toggle RDF ("r")</button> <button id="toggleExamples">Toggle Examples ("e")</button> <button id="toggleSquished">Render only abstract syntax ("a")</button -->

      <section id="results">
        <h3>Results</h3>
        <div>
          <p>
            ShEx does not prescribe a report format.
            For illustration purposes in this specification, results of validation are represented in a table associating node/shape pairs with a pass or fail and a reason for failure:
          </p>
        <table class="example">
          <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
          <tr class="pass"><td>&lt;Shape1&gt;</td><td>&lt;node1&gt;</td><td>pass</td><td class="noreason"></td></tr>
          <tr class="fail"><td>&lt;Shape1&gt;</td><td>&lt;node2&gt;</td><td>fail</td><td class="fail">no <code>ex:state</code> supplied.</td></tr>
        </table>
        </div>
        </section>
      <!-- @@Labra: I am not sure, but I think it would be more readable if you used the compact syntax by default and the Json as secondary. 
          Also, I would prefer to see both at the same time as in the OWL Primer: https://www.w3.org/TR/owl2-primer/ where you can activate/deactiva 
          each of the styles separately
          Finally, I also think it would be nice to also include examples using the JSON-LD/RDF based serialization -->
      <!-- @@ericP: I think we have to use ShExJ as the default syntax as it's the foundation for the definitions of the semantics.
           Let's see if we can get ShExR done in time, though it will be more chatty than ShExJ. -->
      <!-- <p> -->
      <!--   The following HTML tags and CSS classes are used to highlight the roles of text in this document: -->
      <!-- </p> -->
      <!-- <ul> -->
      <!--   <li>&lt;dfn&gt;<dfn id="dfn-shacl-defined-term">defined term</dfn>&lt;dfn&gt;</li> -->
      <!--   <li>&lt;a class="internalDFN"&gt;<a title="SHACL defined term" href="#dfn-shacl-defined-term" class="internalDFN">defined term</a>&lt;/a&gt;</li> -->
      <!--   <li><sup class="eval">eval</sup> &mdash; link to evaluation semantics</li> -->
      <!-- </ul> -->
    </section>

    <section id="terminology">
      <h2>Terminology</h2>
      <p>Shape expressions are defined using terms from RDF semantics[[!rdf11-mt]]:</p>
      <ul>
        <li><a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-node">Node</a>: one of <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri" class="math">IRI</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-blank-node" class="math">blank node</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal" class="math">Literal</a></li>
        <li><a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-rdf-graph" class="math">Graph</a>: a set of <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-rdf-triple" class="math">Triples</a> of (<a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-subject" class="math">subject</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-predicate" class="math">predicate</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-object" class="math">object</a>)</li>
      </ul>
      <p>
  The following functions access the elements of an RDF graph <m>G</m> containing a node <m>n</m>:</p>
  <ul>
    <li>
      <m>arcsOut(G, n)</m> is the set of triples in a graph <m>G</m> with subject <m>n</m>.
    </li>
    <li>
      <m>predicatesOut(G, n)</m> is the set of predicates in <m>arcsOut(G, n)</m>.
    </li>
    <li>
      <m>arcsIn(G, n)</m> is the set of triples in a graph <m>G</m> with object <m>n</m>.
    </li>
    <li>
      <m>predicatesIn(G, n)</m> is the set of predicates in <m>arcsIn(G, n)</m>.
    </li>
    <li>
      <m>neigh(G, n)</m> is the neighbourhood of the node <m>n</m> in the graph <m>G</m>.<br/><m>neigh(G, n) = arcsOut(G, n) ‚à™ arcsIn(G, n)</m>
    </li>
    <li>
      <m>predicates(G, n)</m> is the set of predicates in <m>neigh(G, n)</m>.<br/><m>predicates(G, n) = predicatesOut(G, n) ‚à™ predicatesIn(G, n)</m>
    </li>
  </ul>

      <div class="example">
  <p>
    Consider the RDF graph <m>G</m> represented in Turtle:
  </p>

  <pre class="graph">
PREFIX ex: http://schema.example/
PREFIX inst: http://inst.example/#
PREFIX foaf: http://xmlns.com/foaf/
PREFIX xsd: http://www.w3.org/2001/XMLSchema#

inst:Issue1 
    ex:state      ex:unassigned ;
    ex:reportedBy _:User2 .

_:User2
    foaf:name     "Bob Smith" ;
    foaf:mbox     &lt;mailto:bob@example.org&gt; .
        </pre>
  <p>
    There are two arcs out of <span class="pre">_:User2</span>; <m>arcsOut(G, <span class="pre">_:User2</span>)</m>:
  </p>
  <pre>
    _:User2  foaf:name  "Bob Smith" .
    _:User2  foaf:mbox  &lt;mailto:bob@example.org&gt; .
  </pre>
  <p>
    There is one arc into <span class="pre">_:User2</span>; <m>arcsIn(G, <span class="pre">_:User2</span>)</m>:
  </p>
  <pre>
    inst:Issue1 ex:reportedBy  _:User2 .
  </pre>
  <p>
    There are three arcs in the neighbourhood of <span class="pre">_:User2</span> set, <m>neigh(G, <span class="pre">_:User2</span>)</m>:
  </p>
  <pre>
    _:User2  foaf:name  "Bob Smith" .
    _:User2  foaf:mbox  &lt;mailto:bob@example.org&gt; .
    inst:Issue1 ex:reportedBy  _:User2 .
  </pre>
      </div>
    </section>

    <section id="shapes-language">
      <h2>The Shape Expressions Language</h2>
      <p>
        A Shape Expressions (ShEx) schema is a collection of labeled Shapes and Node Constraints.
        These can be used to describe or test nodes in RDF graphs.
        ShEx does not prescribe a language for associating nodes with shapes but several approaches are <a href="../primer/index.html#associating-nodes-with-shapes">described in the ShEx Primer</a>.
      </p>

      <section id="shapes-schema">
      <h3>Shapes Schema</h3>
      <p>
        A shapes schema is captured in a <span class="jobjref"><a href="#dfn-Shema">Schema</a></span> object:
      </p>
      <div class="shexjTable">
        <table class="shexj">
  <tr class="obj"><th id="dfn-Schema" class="obj">Schema</th><td>{</td><td><span class="param">startActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">start</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">shapes</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>+]? }</td></tr>
        </table>
      </div>
      <p>
        where <span class="param">shapes</span> is a mapping from shape label to shape expression.
      </p>
      <div class="repchoice">
        <pre class="json">{ "type": "Schema", "shapes": {
    "http://schema.example/IssueShape": { <span class="comment">‚Ä¶</span> },
    "_:UserShape": { <span class="comment">‚Ä¶</span> },
    "http://schema.example/EmployeeShape": { <span class="comment">‚Ä¶</span> } } }</pre>
        <pre class="shexc">                                                    
    ex:IssueShape { ‚Ä¶ }
    _:UserShape { ‚Ä¶ }
    ex:EmployeeShape { ‚Ä¶ }
</pre>
      </div>
      </section>

      <section id="shape-map">
      <h3>ShapeMap Definition</h3>

      <p class="issue">
        Since a node may have multiple shapes, this should either be a mapping from a node to a set of shapes <span class="json">{ "n1": [ "S1", "S2"], "n2": [] }</span> or a list of node-shape pairs <span class="json">[ ["n1", "S1"], ["n1", "S2"] }</span>. Which is easier to understand?
      </p>
      <p>
  A <span class="label">ShapeMap</span> is a mapping from node to a set of shapes <m>(Node1: [Shape2, Shape3, ‚Ä¶])</m> where <m>node</m> is an RDF node, and <m>S</m> is a shape label from a schema.
  A node-label association in a <m>ShapeMap</m> indicates that the node <m>Node1</m> satisfies the constraint given by the definition of the shape expressions labeled <m>Shape2</m> and  <m>Shape3</m>.
  We use the JSON list notation <m>[Shape2, Shape3, ‚Ä¶]</m> for sets with the additional understanding that the list neither order nor repetition have any semantic impact.
      </p>

      <div class="example">
  <p>
    Consider a shapes schema with shape labels <span class="json">"http://schema.example/IssueShape"</span>, <span class="json">"_:UserShape"</span>:
  </p>
      <div class="repchoice">
        <pre class="json">{ "type": "Schema", "shapes": {
    "http://schema.example/IssueShape": { <span class="comment">‚Ä¶</span> },
    "_:UserShape": { <span class="comment">‚Ä¶</span> },
    "http://schema.example/EmployeeShape": { <span class="comment">‚Ä¶</span> } } }</pre>
        <pre class="shexc">                                                    
    ex:IssueShape { ‚Ä¶ }
    _:UserShape { ‚Ä¶ }
    ex:EmployeeShape { ‚Ä¶ }
</pre>
      </div>
  <p>
    An example ShapeMap is:
  </p>
  <div class="json">
    <pre>{ "http://inst.example/#Issue1": ["http://schema.example/IssueShape"],
  "_:User2": ["_:UserShape", "http://schema.example/EmployeeShape"] }</pre>
  </div>
      </div>

      <p>
        <span class="label" id="isValid">isValid</span>: The expression <code class="function">isValid(<m>G</m>, <m>m</m>)</code> indicates that for every node/shape pair <m>(n, s)</m> in <m>m</m>, <m>s</m> has a corresponding shape expression <m>se</m> and <code class="function">satisfies(<m>n</m>, <m>se</m>, <m>G</m>, <m>m</m>)</code>.
        <code class="function">satisfies</code> is defined below for each form of shape expression.
      </p>

      <div class="note">
      <p>
  Validation of a graph <m>G</m> does not necessarily require the construction of a ShapeMap with every node in <m>G</m>.
  The validation semantics defined below imply a set of dependencies for validating some node as a shape.
  A validation process that tests every node in a graph against every shape in a schema can be considered to have an input ShapeMap associating each node with the set of all shapes in the schema.
      </p>
      <p>
        The semantics of ShEx are independent from the construction of an input ShapeMap.
        <a href="https://www.w3.org/2001/sw/wiki/ShEx/ShapeMap">https://www.w3.org/2001/sw/wiki/ShEx/ShapeMap</a> has list of popular methods for constructing ShapeMaps.
      </p>
      </div>

      <p>
        Validation of a node against a shape in a schema requires that there is a consistent mapping from node to <!-- @@set of --> shape for every node and shape visited during a validation process.
        The remainder of this document uses a ShapeMap <m>m</m> to indicate that mapping.
      </p>
      </section>

      <section id="shape-expressions">
        <h3>Shape Expressions</h3>
        <p>
          A shape expression is composed of four kinds of objects combined with the algebraic operators And, Or and Not:
        </p>
        <ul>
          <li>
            a node constraint (<span class="jobjref"><a href="#dfn-NodeConstraint">NodeConstraint</a></span>) that defines the set of allowed values of a node.
            These include specification of RDF node kind, literal datatype, XML String and numeric facets and enumeration of value sets.
          </li>
          <li>
            a shape constraint (<span class="jobjref"><a href="#dfn-Shape">Shape</a></span>) that defines a constraint on the allowed neighbourhood of a node, that is, the allowed triples that contain this node as subject or object.
          </li>
          <li>
            a shape reference (<span class="jobjref"><a href="#dfn-shapeRef">shapeRef</a></span>) identifies another shape in the schema.
          </li>
          <li>
            an external shape (<span class="jobjref"><a href="#dfn-ShapeExternal">ShapeExternal</a></span>) which is an extension mechanism to externally define e.g. functional shapes or prohibitively large value sets.
          </li>
        </ul>
        <section id="shape-expressions-shexj">
          <h4>JSON Syntax</h4>

      <div class="shexjTable">
        <table class="shexj">
  <tr class="nob"><th id="dfn-shapeExpr" class="nob">shapeExpr</th>         <td>=</td> <td><a class="objref" href="#dfn-ShapeOr">ShapeOr</a> | <a class="objref" href="#dfn-ShapeAnd">ShapeAnd</a> | <a class="objref" href="#dfn-ShapeNot">ShapeNot</a> | <a class="objref" href="#dfn-NodeConstraint">NodeConstraint</a> | <a class="objref" href="#dfn-Shape">Shape</a> | <a class="objref" href="#dfn-shapeRef">shapeRef</a> | <a class="objref" href="#dfn-ShapeExternal">ShapeExternal</a> ;</td></tr>
  <tr class="obj"><th id="dfn-ShapeOr" class="obj">ShapeOr</th>             <td>{</td> <td><span class="param">id</span>:<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>? <span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
  <tr class="obj"><th id="dfn-ShapeAnd" class="obj">ShapeAnd</th>           <td>{</td> <td><span class="param">id</span>:<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>? <span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
  <tr class="obj"><th id="dfn-ShapeNot" class="obj">ShapeNot</th>           <td>{</td> <td><span class="param">id</span>:<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>? <span class="param">shapeExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a> }</td></tr>
  <tr class="obj"><th id="dfn-shapeRef" class="nob">shapeRef</th>           <td>=</td> <td><a class="objref" href="#dfn-IRI">IRI</a> | <a class="objref" href="#dfn-BNODE">BNODE</a> ;</td></tr>
  <tr class="obj"><th id="dfn-ShapeExternal" class="obj">ShapeExternal</th> <td>{</td> <td><span class="param">id</span>:<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>? }</td></tr>
  <tr class="nob"><th id="dfn-shapeLabel" class="nob">shapeLabel</th>       <td>=</td> <td><a class="trmref" href="#dfn-IRI">IRI</a> | <a class="trmref" href="#dfn-BNODE">BNODE</a> ;</td></tr>
        </table>
      </div>
      <div class="example">
  <p>
    Examples of shape expressions:
  </p>

  <div class="json">
    <pre class="json">{ "type": "Shape", <span class="comment">‚Ä¶</span> }  </pre>
    <!-- pre class="shexc">{ <span class="comment">‚Ä¶</span> }                   </pre -->
  </div>
  <div style="clear:both;">¬†</div>
  <div class="json">
    <pre class="json">{ "type": "ShapeAnd", "shapeExprs": [
  { "type": "NodeConstraint", <span class="comment">‚Ä¶</span> },
  { "type": "ShapeOr", "shapeExprs": [
    "http://schema.example/IssueShape",
    { "type": "ShapeNot", "shapeExpr": { "type": "ShapeExternal" } }
    ] } ] }</pre>
    <!-- pre class="shexc">                                                    
  { "type": "NodeConstraint", <span class="comment">‚Ä¶</span> },
  { "type": "ShapeOr", "shapeExprs": [
    { "type": "ShapeRef", "reference": "http://schema.example/IssueShape" }
    { "type": "ShapeNot", "shapeExpr": { "type": "ShapeExternal" } }
    ] } ] }</pre -->
    In this ShapeOr's <span class="param">shapeExprs</span>,"http://schema.example/IssueShape" is a reference to the shape expression with the id "http://schema.example/IssueShape".
  </div>
      </div>
      </section>
      <section id="shape-expression-semantics">
      <h4>Semantics</h4>
      <p>
        <span class="label" id="satisfies">satisfies</span>: The expression <code class="function">satisfies(<m>n</m>, <m>se</m>, <m>G</m>, <m>m</m>)</code> indicates that a node <m>n</m> and graph <m>G</m> satisfy a shape expression <m>se</m> with shapeMap <m>m</m>.<br/>
        <span class="label" id="notSatisfies">notSatisfies</span>: Conversely, <code class="function">notSatisfies(<m>n</m>, <m>se</m>, <m>G</m>, <m>m</m>)</code> indicates that <m>n</m> and <m>G</m> do not satisfy <m>se</m> with the given shapeMap <m>m</m>.
        <code class="function">notSatisfies(<m>n</m>, <m>se</m>, <m>G</m>, <m>_</m>)</code> indicates that no shapeMap would allow <m>n</m> and <m>G</m> to satisfy <m>se</m>.
      </p>
      <p>
        <code class="function">satisfies(<m>n</m>, <m>se</m>, <m>G</m>, <m>m</m>)</code> is true if and only if:
      </p>

      <ul>
        <li id="satisfies-NodeConstraint"><m>Se</m> is a <span class="jobjref"><a href="#dfn-NodeConstraint" class="obj">NodeConstraint</a></span> and <code class="function"><a href="#satisfies2-NodeConstraint">satisfies2</a>(<m>n</m>, <m>se</m>)</code> as described below in <a href="#node-constraints">Node Constraints</a>.
        Note that testing if a node satisfies a node constraint does not require a graph or shapeMap.</li>
        <li id="satisfies-Shape-proxy"><m>Se</m> is a <span class="jobjref"><a href="#dfn-Shape" class="obj">Shape</a></span> and <code class="function">satisfies(<m>n</m>, <m>se</m>)</code> as <a href="#satisfies-Shape">defined below</a> in Shapes and Triple Expressions.</li>
        <li id="satisfies-ShapeOr"><m>Se</m> is a <span class="jobjref"><a href="#dfn-ShapeOr" class="obj">ShapeOr</a></span> and there is some shape expression <m>se2</m> in <span class="param">shapeExprs</span> such that <code class="function">satisfies(<m>n</m>, <m>se2</m>, <m>G</m>, <m>m</m>)</code>.</li>
        <li id="satisfies-ShapeAnd"><m>Se</m> is a <span class="jobjref"><a href="#dfn-ShapeAnd" class="obj">ShapeAnd</a></span> and for every shape expression <m>se2</m> in <span class="param">shapeExprs</span>, <code class="function">satisfies(<m>n</m>, <m>se2</m>, <m>G</m>, <m>m</m>)</code>.</li>
        <li id="satisfies-ShapeNot"><m>Se</m> is a <span class="jobjref"><a href="#dfn-ShapeNot" class="obj">ShapeNot</a></span> and for the shape expression <m>se2</m> at <span class="param">shapeExpr</span>, <code class="function">notSatisfies(<m>n</m>, <m>se2</m>, <m>G</m>, <m>m</m>)</code>.</li>
        <li id="satisfies-shapeRef"><m>Se</m> is a <span class="jobjref"><a href="#dfn-shapeRef" class="obj">shapeRef</a></span> and the <span class="jobjref"><a href="#dfn-Schema" class="obj">Schema</a></span>'s <span class="param">shapes</span> maps that <span class="param">id</span> to a shape expression <m>se2</m> and <code class="function">satisfies(<m>n</m>, <m>se2</m>, <m>G</m>, <m>m</m>)</code>.</li>
        <li id="satisfies-ShapeExternal"><m>Se</m> is a <span class="jobjref"><a href="#dfn-ShapeExternal" class="obj">ShapeExternal</a></span> and implementation-specific mechansims not defined in this specification indicate success.</li>
      </ul>

      <div class="example">
  <p>
    Given the three shape expressions <m>SE<sub>1</sub></m>, <m>SE<sub>2</sub></m>, <m>SE<sub>3</sub></m> in a <span class="jobjref"><a href="#dfn-Schema" class="obj">Schema</a></span> <m>Sch</m>, such that:
  </p>
  <ul>
    <li><code class="function">satisfies(<m>n</m>, <m>SE<sub>1</sub></m>, <m>G</m>, <m>m</m>)</code></li>
    <li><code class="function">satisfies(<m>n</m>, <m>SE<sub>2</sub></m>, <m>G</m>, <m>m</m>)</code></li>
    <li><code class="function">notSatisfies(<m>n</m>, <m>SE<sub>3</sub></m>, <m>G</m>, <m>m</m>)</code></li>
  </ul>
  <p>
    the following hold:
  </p>

  <ul>
    <li><code><div style="float:left;">satisfies(</div><div style="float:left;"><m>n</m>,<br/><div class="inline json"><pre>{ "type": "ShapeAnd", "shapeExprs": [ <span class="comment">SE<sub>1</sub></span>, <span class="comment">SE<sub>2</sub></span> ] }</pre></div>,<br/> <m>G</m>, <m>m</m>)</div></code><div style="clear:both;"></div></li>
    <li><code><div style="float:left;">satisfies(</div><div style="float:left;"><m>n</m>,<br/><div class="inline json"><pre>{ "type": "ShapeOr", "shapeExprs": [ <span class="comment">SE<sub>1</sub></span>, <span class="comment">SE<sub>2</sub></span>, <span class="comment">SE<sub>3</sub></span> ] }</pre></div>,<br/> <m>G</m>, <m>m</m>)</div></code><div style="clear:both;"></div></li>
    <li><code><div style="float:left;">notSatisfies(</div><div style="float:left;"><m>n</m>,<br/><div class="inline json"><pre>{ "type": "ShapeNot", "shapeExpr": {
    { "type": "ShapeOr", "shapeExprs": [
        <span class="comment">SE<sub>1</sub></span>,
        { "type": "ShapeAnd", "shapeExprs": [ <span class="comment">SE<sub>2</sub></span>, <span class="comment">SE<sub>3</sub></span> ] }
      ] }
  } }</pre></div>,<br/> <m>G</m>, <m>m</m>)</div></code><div style="clear:both;"></div></li>
    </ul>

    <p>
      If <m>Sch</m>'s <span class="param">shapes</span> maps "<code>http://schema.example/shape1</code>" to <m>SE<sub>1</sub></m> then the following holds:
    </p>
  <ul>
    <li><code><div style="float:left;">satisfies(</div><div style="float:left;"><m>n</m>,<br/><div class="inline json"><pre>http://schema.example/shape1"</pre></div>,<br/> <m>G</m>, <m>m</m>)</div></code><div style="clear:both;"></div></li>
    </ul>
      </div>
      </section>
      </section>

      <section id="node-constraints">
        <h3>Node Constraints</h3>
        <div class="shexjTable">
          <table class="shexj">
  <tr class="obj"><th id="dfn-NodeConstraint" class="obj">NodeConstraint</th><td>{</td><td><span class="param">nodeKind</span>:(<span class="literal">"iri"</span> | <span class="literal">"bnode"</span> | <span class="literal">"nonliteral"</span> | <span class="literal">"literal"</span>)? <span class="param">datatype</span>:<a class="trmref" href="#dfn-IRI">IRI</a>? <a class="nobref" href="#dfn-xsFacet">xsFacet</a>* <span class="param">values</span>:[<a class="nobref" href="#dfn-valueSetValue">valueSetValue</a>]? }</td></tr>
  <tr class="nob"><th id="dfn-xsFacet" class="nob">xsFacet</th><td>=</td><td><a class="nobref" href="#dfn-stringFacet">stringFacet</a> | <a class="nobref" href="#dfn-numericFacet">numericFacet</a> ;</td></tr>
  <tr class="nob"><th id="dfn-stringFacet" class="nob">stringFacet</th><td>=</td><td>(<span class="param">"length"</span>|<span class="param">"minlength"</span>|<span class="param">"maxlength"</span>):<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="param">pattern</span>:<a class="trmref" href="#dfn-STRING">STRING</a> ;</td></tr>
  <tr class="nob"><th id="dfn-numericFacet" class="nob">numericFacet</th><td>=</td><td>(<span class="param">"mininclusive"</span>|<span class="param">"minexclusive"</span>|<span class="param">"maxinclusive"</span>|<span class="param">"maxexclusive"</span>):<a class="nobref" href="#dfn-numericLiteral">numericLiteral</a> </td></tr>
    <tr><th></th><td>|</td><td>(<span class="param">"totaldigits"</span>|<span class="param">"fractiondigits"</span>):<a class="trmref" href="#dfn-INTEGER">INTEGER</a> ;</td></tr>
  <tr class="nob"><th id="dfn-numericLiteral" class="nob">numericLiteral</th><td>=</td><td><a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <a class="trmref" href="#dfn-DECIMAL">DECIMAL</a> | <a class="trmref" href="#dfn-DOUBLE">DOUBLE</a> ;</td></tr>
  <tr class="nob"><th id="dfn-objectValue" class="nob">objectValue</th><td>=</td><td><a class="trmref" href="#dfn-IRI">IRI</a> | <a class="trmref" href="#dfn-STRING">STRING</a> | <a class="trmref" href="#dfn-DATATYPE_STRING">DATATYPE_STRING</a> | <a class="trmref" href="#dfn-LANG_STRING">LANG_STRING</a> ;</td></tr>
  <tr class="nob"><th id="dfn-valueSetValue" class="nob">valueSetValue</th><td>=</td><td><a class="nobref" href="#dfn-objectValue">objectValue</a> | <a class="objref" href="#dfn-Stem">Stem</a> | <a class="objref" href="#dfn-StemRange">StemRange</a> ;</td></tr>
  <tr class="obj"><th id="dfn-Stem" class="obj">Stem</th><td>{</td><td><span class="param">stem</span>:<a class="trmref" href="#dfn-IRI">IRI</a> }</td></tr>
  <tr class="obj"><th id="dfn-StemRange" class="obj">StemRange</th><td>{</td><td><span class="param">stem</span>:(<a class="trmref" href="#dfn-IRI">IRI</a> | <a class="objref" href="#dfn-Wildcard">Wildcard</a>) <span class="param">exclusions</span>:[<a class="nobref" href="#dfn-objectValue">objectValue</a>|<a class="nobref" href="#dfn-Stem">Stem</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-Wildcard" class="obj">Wildcard</th><td>{</td><td><span class="comment">/* empty */</span> }</td></tr>
          </table>
        </div>
        <section id="node-constraint-semantics">
          <h4>Semantics</h4>
          <p id="satisfies2-NodeConstraint">
            For a node <span class="param">n</span> and constraint <span class="param">nc</span>, <code class="function">satisfies2(<m>n</m>, <m>nc</m>)</code> if and only if for every <span class="param">nodeKind</span>, <span class="param">datatype</span>, <span class="param">xsFacet</span> and <span class="param">values</span> constraint value <m>v</m> present in <span class="param">nc</span> <code class="function">nodeSatisfies(<m>n</m>, <m>v</m>)</code>.
            The following sections define <code class="function">nodeSatisfies</code> for each of these types of constraints:
          </p>
          <ul>
            <li><a href="#nodeKind">Node Kind Constraints</a></li>
            <li><a href="#datatype">Datatype Constraints</a></li>
            <li><a href="#xs-string">XML Schema String Facet Constraints</a></li>
            <li><a href="#xs-numeric">XML Schema Numeric Facet Constraints</a></li>
            <li><a href="#values">Values Constraints</a></li>
          </ul>
        </section>

        <section id="nodeKind">
          <h4>Node Kind Constraints</h4>
          <p id="nodeSatisfies-nodeKind">
            For a node <m>n</m> and constraint value <m>v</m>, <code class="function">nodeSatisfies(<m>n</m>, <m>v</m>)</code> if:
          </p>
          <ul>
            <li><m>v</m> = "iri" and <m>n</m> is an IRI.</li>
            <li><m>v</m> = "bnode" and <m>n</m> is a blank node.</li>
            <li><m>v</m> = "literal" and <m>n</m> is a Literal.</li>
            <li><m>v</m> = "nonliteral" and <m>n</m> is an IRI or blank node.</li>
          </ul>
          <div class="example">
            <div class="example-title marker"><span>Node Kind example 1</span></div>
            <p>
              The following examples use a <span class="jobjref"><a href="#dfn-TripleConstraint">TripleConstraint</a></span> object described later in the document.
              The 
            </p>
            <div class="repchoice">
              <pre class="json">{ "type": "Schema", "shapes": {
    "http://schema.example/IssueShape": {
    "type": "Shape", "expression": {
      "type": "TripleConstraint", "predicate": "http://schema.example/state",
      "valueExpr": { "type": "NodeConstraint", "nodeKind": "iri" } } } } }</pre>
              <pre class="shexc">                                                     
    ex:IssueShape {                                                          
      ex:state IRI
    }
              </pre>
            </div>
            <pre class="data">
&lt;issue1&gt; ex:state ex:HunkyDory .
&lt;issue2&gt; <span style="border-bottom: thin solid red;">ex:taste</span> ex:GoodEnough .
<span class="fail">&lt;issue3&gt; ex:state "just fine" .</span></pre>
<!-- @@Labra: I think the second example could be omitted at this point because it requires talking about cardinality which has not
     been introduced yet...-->
<!-- @@ericP: I believe that mentioning it here will reduce confusion for readers. -->
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td><td class="noreason"></td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail">expected 1 <code>ex:state</code> property.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:state</code> expected to be an IRI, literal found.</td></tr>
            </table>
            <p>
              Note that &lt;issue2&gt; <span class="fail">fails</span> not because of a nodeKind violation but instead because of a <a href="#cardinality">Cardinality</a> violation described below.
            </p>
          </div>
        </section>

        <section id="datatype">
          <h4>Datatype Constraints</h4>
          <p id="nodeSatisfies-datatype">
            For a node <m>n</m> and constraint value <m>v</m>, <code class="function">nodeSatisfies(<m>n</m>, <m>v</m>)</code> if <m>n</m> is an Literal with the datatype <m>v</m> and, if <m>v</m> is in the set of <a href="https://www.w3.org/TR/sparql11-query/#operandDataTypes">SPARQL operand data types</a>[[!sparql11-query]], an XML schema string with a value of the lexical form of <m>n</m> can be cast to the target type <m>v</m> per <a href="https://www.w3.org/TR/xpath-functions/#casting">XPath 2.0 section 17, Casting</a>[[!xpath-functions]].
            Only datatypes supported by SPARQL MUST be tested but ShEx extensions MAY add support for other datatypes.
          </p>

          <div class="example">
            <div class="example-title marker"><span>Datatype example 1</span></div>
            <div class="repchoice">
              <pre class="json">{ "type": "Schema", "shapes": {
  "http://schema.example/IssueShape": {
    "type": "Shape", "expression": {
      "type": "TripleConstraint", "predicate": "http://schema.example/submittedOn",
      "valueExpr": {
        "type": "NodeConstraint",
        "datatype": "http://www.w3.org/2001/XMLSchema#date"
      } } } } }</pre>
              <pre class="shexc">                                                                                   
    ex:IssueShape {                                                          
      ex:submittedOn xsd:date
    }

    
    
              </pre>
            </div>
            <pre class="data">
&lt;issue1&gt; ex:submittedOn "2016-07-08"^^xsd:date .
<span class="fail">&lt;issue2&gt; ex:submittedOn "2016-07-08T01:23:45Z"^^xsd:dateTime .</span>
<span class="fail">&lt;issue3&gt; ex:submittedOn "2016-07"^^xsd:date .</span></pre>
<!-- @@Labra: I would probably use a different datatype to avoid confusion between date and dateTime...maybe xsd:float .... -->
<!-- @@ericP: I think that this example can eliminate readers' questions about whether date forms are somehow compatible. -->
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td><td class="noreason"></td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>ex:submittedOn</code> expected to be an <code>xsd:date</code>, <code>xsd:dateTime</code> found.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>2016-07</code> is not a valid <code>xsd:date</code>.</td></tr>
            </table>
          </div>

          <div class="note">
            <p>
              In RDF 1.1, <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string">language-tagged strings</a>[[!rdf11-concepts]] have the datatype <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#langString</code>.
            </p>
            <p>
              RDF 1.0 included RDF literals with no datatype or language tag.
              These are called "<a href="https://www.w3.org/TR/sparql11-query/#simple_literal">simple literals</a>" in SPARQL11[[!sparql11-query]].
              In RDF 1.1, these literals have the datatype <code>http://www.w3.org/2001/XMLSchema#string</code>.
            </p>
          </div>
          <div class="example">
            <div class="example-title marker"><span>Datatype example 2</span></div>
            <div class="repchoice">
              <pre class="json">{ "type": "Schema", "shapes": {
  "http://schema.example/IssueShape": {
    "type": "Shape", "expression": {
      "type": "TripleConstraint",
      "predicate": "http://www.w3.org/2000/01/rdf-schema#label",
      "valueExpr": {
        "type": "NodeConstraint",
        "datatype": "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"
      } } } } }</pre>
              <pre class="shexc">                                                                           
  ex:IssueShape {
    rdfs:label rdf:langString
  }




              </pre>
            </div>
            <pre class="data">
&lt;issue3&gt; rdfs:label "emits dense black smoke"@en .
<span class="fail">&lt;issue4&gt; rdfs:label "unexpected odor" .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>pass</td><td class="noreason"></td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue4&gt;</td><td>fail</td><td class="fail"><code>rdfs:label</code> expected to be an <code>rdf:langString</code>, <code>xsd:string</code> found.</td></tr>
            </table>
          </div>
        </section>
      
      <section id="xs-string">
        <h4>XML Schema String Facet Constraints</h4>
        <!-- ul>
          <li><a href="#length">XML Schema Length Constraints</a></li>
          <li><a href="#minlength">XML Schema Minlength Constraints</a></li>
          <li><a href="#maxlength">XML Schema Maxlength Constraints</a></li>
          <li><a href="#pattern">XML Schema Pattern Constraints</a></li>
        </ul -->
        <p>
          String facet constraints apply to the lexical form of the RDF Literals and IRIs and the labels of blank nodes (see <a href="#blank-node-label">note below regarding access to blank node labels</a>).<br/>
          Let <m>lex</m> =
        </p>
        <ul>
          <li>if the value <m>n</m> is an RDF Literal, the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of the literal (see [[!rdf11-concepts]] section 3.3 Literals).</li>
          <li>if the value <m>n</m> is an IRI, the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-iri">IRI string</a> (see [[!rdf11-concepts]] section 3.2 IRIs).</li>
          <li>if the value <m>n</m> is a blank node, the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-blank-node-identifier">blank node identifier</a> (see [[!rdf11-concepts]] section 3.2 Blank Nodes).</li>
        </ul>
        <p>
          Let <m>len</m> = the number of unicode codepoints in <m>lex</m><br/>
          For a node <m>n</m> and constraint value <m>v</m>, <code class="function">nodeSatisfies(<m>n</m>, <m>v</m>)</code>:
        </p>
        <ul>
          <li id="nodeSatisfies-length">for "<code>length</code>" constraints, <m>v = len</m>,</li>
          <li id="nodeSatisfies-minlength">for "<code>minlength</code>" constraints, <m>v &gt;= len</m>,</li>
          <li id="nodeSatisfies-maxlength">for "<code>maxlength</code>" constraints, <m>v &lt;= len</m>,</li>
          <li id="nodeSatisfies-pattern">for "<code>pattern</code>" constraints, <m>v</m> is a valid <a href="https://www.w3.org/TR/xpath-functions/#regex-syntax">XPath 3.1 regular expression</a>[[!xpath-functions-30]] and invoking <code class="function"><a href="https://www.w3.org/TR/xpath-functions-30/#func-matches">fn:matches</a>(<m>lex</m>, <m>v</m>)</code> returns <code>fn:true</code>.</li>
        </ul>
        <div class="example">
          <div class="example-title marker"><span>String Facets example 1</span></div>
          <div class="repchoice">
            <pre class="json">{ "type": "Schema", "shapes": {
  "http://schema.example/IssueShape": {
    "type": "Shape", "expression": {
      "type": "TripleConstraint",
      "predicate": "http://schema.example/submittedBy",
      "valueExpr": { "type": "NodeConstraint", "minlength": 10 } } } } }</pre>
            <pre class="shexc">                                                                        
  ex:IssueShape {
    ex:submittedBy MINLENGTH 10
  }

            </pre>
          </div>
          <pre class="data">
&lt;issue1&gt; ex:submittedBy &lt;http://a.example/bob&gt; . <span class="comment"># 20 characters</span>
<span class="fail">&lt;issue2&gt; ex:submittedBy "Bob" .</span> <span class="comment"># 3 characters</span></pre>
          <table>
            <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
            <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td><td class="noreason"></td></tr>
            <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>ex:submittedOn</code> expected to be &gt;= 10 characters,<br/> 3 characters found.</td></tr>
          </table>
        </div>

        <div class="note" id="blank-node-label">
          <p>
            Access to blank node labels may be impossible or unadvisable for many use cases.
            For instance, the SPARQL Query and SPARQL Update languages treat blank nodes in the query, labeled or otherwise, as variables.
            Lexical constraints on blank node labels can only be implemented in systems which preserve such labels on data import.
          </p>
          <div class="example">
            <div class="example-title marker"><span>String Facets example 2</span></div>
            <div class="repchoice">
              <pre class="json">{ "type": "Schema", "shapes": {
  "http://schema.example/IssueShape": {
    "type": "Shape", "expression": {
      "type": "TripleConstraint",
      "predicate": "http://schema.example/submittedBy",
      "valueExpr": { "type": "NodeConstraint", "pattern": "genUser[0-9]+" }
} } } }</pre>
              <pre class="shexc">                                                                           
  ex:IssueShape {
    ex:submittedBy PATTERN "genUser[0-9]+"
  }


              </pre>
            </div>
            <pre class="data">
&lt;issue6&gt; ex:submittedBy _:genUser218 .
<span class="fail">&lt;issue7&gt; ex:submittedBy _:genContact817 .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue6&gt;</td><td>pass</td><td class="noreason"></td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue7&gt;</td><td>fail</td><td class="fail"><code>_:genContact817</code> expected to match <code>genUser[0-9]+</code>.</td></tr>
            </table>
          </div>
        </div>
        <p class="issue">
          Neither ShExC or ShExJ provide for regex flags.
        </p>
      </section>

      <section id="xs-numeric">
        <h4>XML Schema Numeric Facet Constraints</h4>
        <!-- ul>
          <li><a href="#mininclusive">XML Schema Mininclusive Constraints</a></li>
          <li><a href="#minexclusive">XML Schema Minexclusive Constraints</a></li>
          <li><a href="#maxinclusive">XML Schema Maxinclusive Constraints</a></li>
          <li><a href="#maxexclusive">XML Schema Maxexclusive Constraints</a></li>
          <li><a href="#totaldigits">XML Schema Totaldigits Constraints</a></li>
          <li><a href="#fractiondigits">XML Schema Fractiondigits Constraints</a></li>
        </ul -->
        <p>
          Numeric facet constraints apply to the numeric value of RDF Literals with datatypes listed in <a href="https://www.w3.org/TR/sparql11-query/#operandDataTypes">SPARQL 1.1 Operand Data Types</a>[[!sparql11-query]].
          Numeric constraints on non-numeric values fail.
          <code>totaldigits</code> and <code>fractiondigits</code> constraints on values not derived from <code>xsd:decimal</code> fail.
        </p>
        <p>
          Let <m>num</m> be the numeric value of <m>n</m>.<br/>
          For a node <m>n</m> and constraint value <m>v</m>, <code class="function">nodeSatisfies(<m>n</m>, <m>v</m>)</code>:
        </p>
        <ul>
          <li id="nodeSatisfies-mininclusive">for "<code>mininclusive</code>" constraints, <m>v &lt;= num</m>,</li>
          <li id="nodeSatisfies-minexclusive">for "<code>minexclusive</code>" constraints, <m>v &lt; num</m>,</li>
          <li id="nodeSatisfies-maxinclusive">for "<code>maxinclusive</code>" constraints, <m>v &gt;= num</m>,</li>
          <li id="nodeSatisfies-maxexclusive">for "<code>maxexclusive</code>" constraints, <m>v &gt; num</m>,</li>
          <li id="nodeSatisfies-totaldigits">for "<code>totaldigits</code>" constraints, <m>v</m> equals the number of digits in the <a href="https://www.w3.org/TR/xmlschema-2/#dt-canonical-representation">XML Schema canonical form</a>[[!xmlschema-2]] of the value of <m>n</m>,</li>
          <li id="nodeSatisfies-fractiondigits">for "<code>fractiondigits</code>" constraints, <m>v</m> is less than or equals the number of digits to the right of the decimal place in the <a href="https://www.w3.org/TR/xmlschema-2/#dt-canonical-representation">XML Schema canonical form</a>[[!xmlschema-2]] of the value of <m>n</m>, ignoring trailing zeros.</li>
        </ul>
        <div class="example">
          <div class="example-title marker"><span>Numeric Facets example 1</span></div>
          <div class="repchoice">
            <pre class="json">{ "type": "Schema", "shapes": {
  "http://schema.example/IssueShape": {
    "type": "Shape", "expression": {
      "type": "TripleConstraint",
      "predicate": "http://schema.example/confirmations",
      "valueExpr": { "type": "NodeConstraint", "mininclusive": 1 } } } } }</pre>
            <pre class="shexc">                                                                          
  ex:IssueShape {
    ex:confirmations MININCLUSIVE 1
  }

            </pre>
          </div>
            <pre class="data">
&lt;issue1&gt; ex:confirmations 1 .
&lt;issue2&gt; ex:confirmations 0 .
<span class="fail">&lt;issue3&gt; ex:confirmations "ii"^^ex:romanNumeral .</span></pre>
<!-- @@Labra: Maybe this example is not needed here because it is checking datatypes not numeric facets ... -->
<!-- @@ericP: I think it clarifies that min/max only work with recognized datatypes. -->
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td><td class="noreason"></td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>0</code> is less than <code>1</code>.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:romanNumeral</code> is not a numeric datatype.</td></tr>
            </table>
          </div>
      </section>

      <section id="values">
        <h4>Values Constraint</h4>
        <p>
          The <code><a href="#nodeSatisfies">nodeSatisfies</a></code> semantics for <span class="jobjref"><a href="#dfn-NodeConstraint" class="obj">NodeConstraint</a></span> <span class="param">values</span> depends on a <code>nodeIn</code> function <a href="#nodeIn">defined below</a>.
        </p>
        <p>
          For a node <m>n</m> and constraint value <m>v</m>, <code class="function">nodeSatisfies(<m>n</m>, <m>v</m>)</code> if <m>n</m> matches some <a class="nobref" href="#dfn-valueSetValue">valueSetValue</a> <m>vsv</m> in <m>v</m>.
          A term matches a valueSetValue if:
        </p>
        <ul>
          <li><m id="nodeSatisfies-objectValue">vsv</m> is an <a class="nobref" href="#dfn-objectValue">objectValue</a> and <m>n = vsv</m>.</li>
          <li><m id="nodeSatisfies-Stem">vsv</m> is a <a class="nobref" href="#dfn-Stem">Stem</a> with <span class="param">stem</span> <m>st</m> and <m>nodeIn(n, st)</m>.</li>
          <li><m id="nodeSatisfies-StemRange">vsv</m> is a <a class="nobref" href="#dfn-StemRange">StemRange</a> with <span class="param">stem</span> <m>st</m> and <span class="param">exclusions</span> <m>excls</m> and <m class="function">nodeIn(n, st)</m> and there is no <m>x</m> in <m>excls</m> such that <m class="function">nodeIn(n, excl)</m>.</li>
          <li><m id="nodeSatisfies-Wildcard">vsv</m> is a <a class="nobref" href="#dfn-Wildcard">Wildcard</a> with <span class="param">exclusions</span> <m>excls</m> and there is no <m>x</m> in <m>excls</m> such that <m class="function">nodeIn(n, excl)</m>.</li>
        </ul>
        <p>
          <span class="label" id="nodeIn">nodeIn</span>: asserts that an RDF node <m>n</m> is equal to an IRI or is in a set defined by a <span class="jobjref"><a href="#dfn-Stem" class="obj">Stem</a></span>.<br/>
          The expression <code class="function">nodeIn(<m>n</m>, <m>s</m>)</code> is satisfied if:
        </p>
        <ul>
          <li><m>s</m> is an IRI and <m>n = s</m>.</li>
          <li><m>s</m> is a <span class="jobjref"><a href="#dfn-Stem" class="obj">Stem</a></span> with <span class="param">stem</span> <m>st</m> and:
          <ul>
            <li><m>n</m> is an IRI and <m class="function"><a href="https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-starts-with">fn:starts-with</a>(n, st)</m>.</li>
            <li><m>n</m> is a blank node with label <m>l</m> and <m class="function"><a href="https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-starts-with">fn:starts-with</a>(l, st)</m>.</li>
          </ul></li>
        </ul>
        <div class="example">
          <div class="example-title marker"><span>Values Constraint example 1</span></div>
          <p>NoActionIssueShape requires a state of Resolved or Rejected:</p>
          <div class="repchoice">
            <pre class="json">{ "type": "Schema", "shapes": {
  "http://schema.example/NoActionIssueShape": {
    "type": "Shape", "expression": {
      "type": "TripleConstraint",
      "predicate": "http://schema.example/state",
      "valueExpr": {
        "type": "NodeConstraint", "values": [
          "http://schema.example/Resolved",
          "http://schema.example/Rejected" ] } } } } }</pre>
            <pre class="shexc">                                                      
  ex:NoActionIssueShape {
    ex:state [ ex:Resolved ex:Rejected ]
  }




            </pre>
          </div>
          <pre class="data">
&lt;issue1&gt; ex:state ex:Resolved .
<span class="fail">&lt;issue2&gt; ex:state ex:Unresolved .</span></pre>
          <table>
            <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
            <tr class="pass"><td>&lt;NoActionIssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td><td class="noreason"></td></tr>
            <tr class="fail"><td>&lt;NoActionIssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>ex:state</code> expected to be <code>ex:Resolved</code> or <code>ex:Rejected</code>, <code>ex:Unresolved</code> found.</td></tr>
          </table>
        </div>

        <div class="example">
          <div class="example-title marker"><span>Values Constraint example 2</span></div>
          <p>An employee must have an email address that is the string "N/A" or starts with "engineering-"  or "sales-" but not "sales-contacts" or "sales-interns":</p>
          <div class="repchoice">
            <pre class="json">{ "type": "Schema", "shapes": {
  "http://schema.example/EmployeeShape": {
    "type": "Shape", "expression": {
      "type": "TripleConstraint",
      "predicate": "http://xmlns.com/foaf/0.1/mbox",
      "valueExpr": {
        "type": "NodeConstraint", "values": [
          "\"N/A\"",
          { "type": "StemRange", "stem": "mailto:engineering-" },
          { "type": "StemRange", "stem": "mailto:sales-", "exclusions": [
              { "type": "Stem", "stem": "mailto:sales-contacts" },
              { "type": "Stem", "stem": "mailto:sales-interns" }
            ] }
        ] } } } } }</pre>
            <pre class="shexc">                                                                         
  ex:EmployeeShape {
    foaf:mbox [ "N/A"
                &lt;mailto:engineering-&gt;~
                &lt;mailto:sales-&gt;~
                    - &lt;mailto:sales-contacts&gt;~
                    - &lt;mailto:sales-interns&gt;~ ]
  }





            </pre>
          </div>
          <pre class="data">
&lt;issue3&gt; foaf:mbox "N/A" .
&lt;issue4&gt; foaf:mbox &lt;mailto:engineering-2112@a.example&gt; .
&lt;issue5&gt; foaf:mbox &lt;mailto:sales-835@a.example&gt; .
<span class="fail">&lt;issue6&gt; foaf:mbox "missing" .</span>
<span class="fail">&lt;issue7&gt; foaf:mbox &lt;mailto:sales-contacts-999@a.example&gt; .</span></pre>
          <table>
            <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
            <tr class="pass"><td>&lt;EmployeeShape&gt;</td><td>&lt;issue3&gt;</td><td>pass</td><td class="noreason"></td></tr>
            <tr class="pass"><td>&lt;EmployeeShape&gt;</td><td>&lt;issue4&gt;</td><td>pass</td><td class="noreason"></td></tr>
            <tr class="pass"><td>&lt;EmployeeShape&gt;</td><td>&lt;issue5&gt;</td><td>pass</td><td class="noreason"></td></tr>
            <tr class="fail"><td>&lt;EmployeeShape&gt;</td><td>&lt;issue6&gt;</td><td>fail</td><td class="fail"><code>"missing"</code> is not in value set.</td></tr>
            <tr class="fail"><td>&lt;EmployeeShape&gt;</td><td>&lt;issue7&gt;</td><td>fail</td><td class="fail"><code>&lt;mailto:sales-contacts-999@a.example&gt;</code> is excluded.</td></tr>
          </table>
        </div>

        <div class="example">
          <div class="example-title marker"><span>Values Constraint example 3</span></div>
          <p>An employee must not have an email address that starts with "engineering-"  or "sales-":</p>
          <div class="repchoice">
            <pre class="json">{ "type": "Schema", "shapes": {
  "http://schema.example/EmployeeShape": {
    "type": "Shape", "expression": {
      "type": "TripleConstraint",
      "predicate": "http://xmlns.com/foaf/0.1/mbox",
      "valueExpr": {
        "type": "NodeConstraint", "values": [
          { "type": "StemRange", "stem": {"type": "Wildcard"},
            "exclusions": [
              { "type": "Stem", "stem": "mailto:engineering-" },
              { "type": "Stem", "stem": "mailto:sales-" }
            ] }
        ] } } } } }</pre>
            <pre class="shexc">                                                                
  ex:EmployeeShape {
    foaf:mbox [ . - &lt;mailto:engineering-&gt;~ - &lt;mailto:sales-&gt;~ ]
  }








            </pre>
          </div>
          <pre class="data">
&lt;issue8&gt; foaf:mbox 123 .
&lt;issue9&gt; foaf:mbox &lt;mailto:core-engineering-2112@a.example&gt; .
<span class="fail">&lt;issue10&gt; foaf:mbox &lt;mailto:engineering-2112@a.example&gt; .</span></pre>
          <table>
            <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
            <tr class="pass"><td>&lt;EmployeeShape&gt;</td><td>&lt;issue8&gt;</td><td>pass</td><td class="noreason"></td></tr>
            <tr class="pass"><td>&lt;EmployeeShape&gt;</td><td>&lt;issue9&gt;</td><td>pass</td><td class="noreason"></td></tr>
            <tr class="fail"><td>&lt;EmployeeShape&gt;</td><td>&lt;issue10&gt;</td><td>fail</td><td class="fail"><code>&lt;mailto:engineering-2112@a.example&gt;</code> is excluded.</td></tr>
          </table>
        </div>

        <p>
          A value set can have a single value in it.
          This is used to indicate that a specific value is required, e.g. that an ex:state must be equal to &lt;http://schema.example/Resolved&gt; or the rdf:type of some node must be foaf:Person.
        </p>
      </section>
    </section>
      <section id="shapes-and-TEs">
        <h3>Shapes and Triple Expressions</h3>
      
      <p>
        Triple expressions are used for defining patterns composed of triple constraints.
        Shapes associate triple expressions with flags indicating whether triples match if they do not correspond to triple constraints in the triple expression.
        A triple expression is composed of <span class="jobjref"><a href="#dfn-TripleConstraint">TripleConstraint</a></span> and <span class="jobjref"><a href="#dfn-inclusion">inclusion</a></span> objects composed with grouping and choice operators.
      </p>
      
      <section id="triple-expressions-abstract-syntax">
      <h4>JSON Syntax</h4>

      <div class="shexjTable">
        <table class="shexj">
  <tr class="obj"><th id="dfn-Shape" class="obj">Shape</th><td>{</td><td><!-- <span class="param">virtual</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>?  --><span class="param">closed</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">extra</span>:[<a class="trmref" href="#dfn-IRI">IRI</a>]? <span class="param">expression</span>:<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>?<!-- <span class="param">inherit</span>:[<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>]? --> <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? }</td></tr>
  <tr class="nob"><th id="dfn-tripleExpr" class="nob">tripleExpr</th><td>=</td><td><a class="objref" href="#dfn-EachOf">EachOf</a> | <a class="objref" href="#dfn-OneOf">OneOf</a> | <a class="objref" href="#dfn-TripleConstraint">TripleConstraint</a> | <a class="objref" href="#dfn-inclusion">inclusion</a> ;</td></tr>
  <tr class="obj"><th id="dfn-EachOf" class="obj">EachOf</th><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-OneOf" class="obj">OneOf</th><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-TripleConstraint" class="obj">TripleConstraint</th><td>{</td><td><span class="param">inverse</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">valueExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-inclusion" class="nob">inclusion</th><td>=</td><td><a class="objref" href="#dfn-IRI">IRI</a> | <a class="objref" href="#dfn-BNODE">BNODE</a> ;</td></tr>
        </table>
      </div>
      </section>
      
      <section id="triple-expressions-semantics">
        <h4>Semantics</h4>
        <p id="satisfies-Shape">
          The <code><a href="#satisfies">satisfies</a></code> semantics for a <span class="jobjref"><a href="#dfn-Shape" class="obj">Shape</a></span> depend on a <code>matches</code> function <a href="#matches">defined below</a>.
          For a node <m>n</m>, shape <m>S</m>, graph <m>G</m>, and shapeMap <m>m</m>, <code class="function">satisfies(<m>n</m>, <m>S</m>, <m>G</m>, <m>m</m>)</code> if and only if:
        </p>
        <ul>
          <li>
            <code class="function">neigh(<m>G</m>, <m>n</m>)</code> can be partitioned into two sets <m>matched</m> and <m>remainder</m> such that <code class="function">matches(<m>matched</m>, <span class="param">expression</span>, <m>m</m>)</code>.
            If <span class="param">expression</span> is absent, <code class="function"><m>remainder</m> = neigh(<m>G</m>, <m>n</m>)</code>.<br/>
            Let <span class="label">outs</span> be the arcsOut in <m>remainder</m>:
            <code class="function"><m>outs</m> = <m>remainder</m> ‚à© arcsOut(<m>G</m>, <m>n</m>)</code>.<br/>
            Let <span class="label">matchables</span> be the triples in <m>outs</m> whose predicate appears in a <span class="jobjref"><a href="#dfn-TripleConstraint" class="obj">TripleConstraint</a></span> in <span class="param">expression</span>.
            If <span class="param">expression</span> is absent, <code class="function"><m>matchables</m> = <m>√ò</m> (the empty set)</code>.<br/>
          </li>
          <li>
            There is no triple in <span class="label">matchables</span> which matches a <span class="jobjref"><a href="#dfn-TripleConstraint" class="obj">TripleConstraint</a></span> in <span class="param">expression</span>.<br/>
            Let <span class="label">unmatchables</span> be the triples in <m>outs</m> which are not in <m>matchables</m>.
            <code class="function"><m>matchables</m> ‚à™ <m>unmatchables</m> = <m>outs</m></code>.
          </li>
          <li>
            There is no triple in <m>matchables</m> whose predicate does not appear in <span class="param">extra</span>.
          </li>
          <li><span class="param">closed</span> is false or <m>unmatchables</m> is empty.</li>
        </ul>
      <p>
        <span class="label" id="matches">matches</span>: asserts that a triple expression is matched by a set of triples that come from the neighbourhood of a node in an RDF graph.
        The expression <code>matches(<m>T</m>, <m>expr</m>, <m>m</m>)</code> indicates that a set of triples <m>T</m> can satisfy these rules:
      </p>
      <ul>
        <li>
          <p id="matches-semActs"><m>expr</m> has <span class="param">semActs</span> and <code class="function">matches(<m>T</m>, <m>expr</m>, <m>m</m>)</code> by the remaining rules in this list and the evaluation of <span class="param">semActs</span> succeeds according to the section below on <a href="#semantic-actions">Semantic Actions</a>.</p>
          <div class="example">
            <m><div style="float:left;">matches(</div><div style="float:left;">T,<br/>
            <div class="inline json">
              <pre>{ "type": "OneOf", "shapeExprs": [<span class="comment">te<sub>1</sub></span>, <span class="comment">te<sub>2</sub>, ‚Ä¶</span>], "min": 2, "max": 3,
  "semActs": [<span class="comment">SemAct<sub>1</sub></span>, <span class="comment">SemAct<sub>2</sub>, ‚Ä¶</span>] }</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;">evaluates as:</div>
            <m><div style="float:left;">matches(</div><div style="float:left;">T,<br/>
            <div class="inline json">
              <pre>{ "type": "OneOf", "shapeExprs": [<span class="comment">te<sub>1</sub></span>, <span class="comment">te<sub>2</sub>, ‚Ä¶</span>], "min": 2, "max": 3 }</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;"></div>
            <m class="function">and <a href="#semActsSatisfied">semActsSatisfied</a>(<span class="inline json">[<span class="comment">SemAct<sub>1</sub></span>, <span class="comment">SemAct<sub>2</sub>, ‚Ä¶</span>]</span>)</m>
          </div>
        </li>
        <li>
          <p id="matches-cardinality"><m>expr</m> has a <span class="label">cardinality</span> of <span class="param">min</span> and/or <span class="param">max</span> not equal to 1 and <m>T</m> can be partitioned into <m>k</m> subsets <m class="function">T<sub>1</sub></m>, <m>T<sub>2</sub></m>,‚Ä¶<m>T<sub>k</sub></m> such that <m>min ‚â§ k ‚â§ max</m> and for each <m>T<sub>n</sub></m>, <code class="function">matches(<m>T<sub>n</sub></m>, <m>expr</m>, <m>m</m>)</code> by the remaining rules in this list.</p>
          <div class="example">
            <m><div style="float:left;">matches(</div><div style="float:left;">T,<br/>
            <div class="inline json">
              <pre>{ "type": "OneOf", "shapeExprs": [<span class="comment">te<sub>1</sub></span>, <span class="comment">te<sub>2</sub>, ‚Ä¶</span>], "min": 2, "max": 3 }</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;">evaluates as:</div>
            <m><div style="float:left;">Let e =¬†</div><div style="float:left;">
            <div class="inline json">
              <pre>{ "type": "OneOf", "shapeExprs": [<span class="comment">te<sub>1</sub></span>, <span class="comment">te<sub>2</sub>, ‚Ä¶</span>] }</pre></div></div>
            <div style="clear:both;"></div>
            (<m class="function">matches(T<sub>1</sub>, e, m)</m> and
             <m class="function">matches(T<sub>2</sub>, e, m)</m><br/>
             ¬†and T = T<sub>1</sub> ‚à™ T<sub>2</sub>)<br/>
            or<br/>
            (<m class="function">matches(T<sub>1</sub>, e, m)</m> and
              <m class="function">matches(T<sub>2</sub>, e, m)</m> and
              <m class="function">matches(T<sub>3</sub>, e, m)</m><br/>
              ¬†and T = T<sub>1</sub> ‚à™ T<sub>2</sub> ‚à™ T<sub>3</sub>)</m>
          </div>
          <!-- div class="example">
            <m><div style="float:left;">matches(</div><div style="float:left;">T,<br/>
            <div class="inline json">
              <pre>{ "type": "OneOf", "shapeExprs": [<span class="comment">te<sub>1</sub></span>, <span class="comment">te<sub>2</sub>, ‚Ä¶</span>], "min": 2, "max": 2 }</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;">evaluates as:</div>
            <m><div style="float:left;">Let subExpr =¬†</div><div style="float:left;">
            <div class="inline json">
              <pre>{ "type": "OneOf", "shapeExprs": [<span class="comment">te<sub>1</sub></span>, <span class="comment">te<sub>2</sub>, ‚Ä¶</span>] }</pre></div></div>
            </m>
            <div style="clear:both;"></div>
            <m><div style="float:left;">matches(</div><div style="float:left;"><m>T<sub>1</sub></m>,<br/>
            <div class="inline json">
              <pre>{ "type": "OneOf", "shapeExprs": [<span class="comment">te<sub>1</sub></span>, <span class="comment">te<sub>2</sub>, ‚Ä¶</span>] }</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;"></div>
            <m><div style="float:left;">and¬†matches(</div><div style="float:left;"><m>T<sub>2</sub></m>,<br/>
            <div class="inline json">
              <pre>{ "type": "OneOf", "shapeExprs": [<span class="comment">te<sub>1</sub></span>, <span class="comment">te<sub>2</sub>, ‚Ä¶</span>] }</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;"></div>
            <m class="function">and T = T<sub>1</sub> ‚à™ T<sub>2</sub></m>
          </div -->
        </li>
        <li>
          <p id="matches-OneOf"><m>expr</m> is a <span class="jobjref"><a href="#dfn-OneOf" class="obj">OneOf</a></span> and there is some shape expression <m>se2</m> in <span class="param">shapeExprs</span> such that a <code class="function">matches(<m>T</m>, <m>se2</m>, <m>m</m>)</code>.</p>
          <div class="example">
            <m><div style="float:left;">matches(</div><div style="float:left;">T,<br/>
            <div class="inline json">
              <pre>{ "type": "OneOf", "shapeExprs": [
  { "type": "EachOf", "shapeExprs": [<span class="comment">te<sub>3</sub></span>, <span class="comment">te<sub>4</sub>, ‚Ä¶</span>] },
  { "type": "TripleExpression", "min": 1, "max": "*",
    "predicate": "http://xmlns.com/foaf/0.1/name" }
] }</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;">evaluates as:</div>
            <m><div style="float:left;">matches(</div><div style="float:left;">T,<br/>
            <div class="inline json">
              <pre>{ "type": "EachOf", "shapeExprs": [<span class="comment">te<sub>3</sub></span>, <span class="comment">te<sub>4</sub>, ‚Ä¶</span>] }</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;"></div>
            <m><div style="float:left;">or matches(</div><div style="float:left;">T,<br/>
            <div class="inline json">
              <pre>{ "type": "TripleExpression", "min": 1, "max": "*",
    "predicate": "http://xmlns.com/foaf/0.1/name" }</pre></div>,<br/>
              m)</div>
            </m>
          </div>
        </li>
        <li>
          <p id="matches-EachOf"><m>expr</m> is an <span class="jobjref"><a href="#dfn-EachOf" class="obj">EachOf</a></span> and there is some partition of <m>T</m> into <m>T<sub>1</sub></m>, <m>T<sub>2</sub></m>,‚Ä¶ such that for every expression <span class="function"><m>expr<sub>1</sub></m>, <m>expr<sub>2</sub></m>,‚Ä¶</span> in <span class="param">shapeExprs</span>, <code class="function">matches(<m>T<sub>n</sub></m>, <m>expr<sub>n</sub></m>, <m>m</m>)</code>.</p>
          <div class="example">
            <m><div style="float:left;">matches(</div><div style="float:left;">T,<br/>
            <div class="inline json">
              <pre>{ "type": "EachOf", "shapeExprs": [
  { "type": "TripleExpression",
    "predicate": "http://xmlns.com/foaf/0.1/givenName" },
  { "type": "TripleExpression",
    "predicate": "http://xmlns.com/foaf/0.1/familyName" }
] }</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;">evaluates as:</div>
            <m><div style="float:left;">matches(</div><div style="float:left;">T<sub>1</sub>,<br/>
            <div class="inline json">
              <pre>{ "type": "TripleExpression",
    "predicate": "http://xmlns.com/foaf/0.1/givenName" }</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;"></div>
            <m><div style="float:left;">and matches(</div><div style="float:left;">T<sub>2</sub>,<br/>
            <div class="inline json">
              <pre>{ "type": "TripleExpression",
    "predicate": "http://xmlns.com/foaf/0.1/familyName" }</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;"></div>
            <m>and T = T<sub>1</sub> ‚à™ T<sub>2</sub></m>
          </div>
        </li>
        <li>
          <p id="matches-TripleConstraint"><m>expr</m> is a <span class="jobjref"><a href="#dfn-TripleConstraint" class="obj">TripleConstraint</a></span> and:</p>
          <ul>
            <li>
              <m>T</m> is a set of one triple.<br/>
              Let <span class="label">t</span> be the soul triple in <m>T</m>.
            </li>
            <li>
              <m>t</m>'s <span class="param">predicate</span> equals <m>expr</m>'s predicate.<br/>
              Let <span class="label">value</span> be <m>t</m>'s subject if <span class="param">inverse</span> is true, else <m>t</m>'s object.
            </li>
            <li>
              if <span class="param">inverse</span> is true, <m>t</m> is in <m>arcsIn</m>, else <m>t</m> is in <m>arcsOut</m>.
            </li>
            <li>either
            <ul>
              <li>
                <p><m>expr</m> has no <span class="param">valueExpr</span></p>
                <div class="example">
                  <m><div style="float:left;">matches(</div><div style="float:left;">T,<br/>
                  <div class="inline json">
                    <pre>{ "type": "TripleExpression",
  "predicate": "http://xmlns.com/foaf/0.1/givenName" }</pre></div>,<br/>
              m)</div>
                  </m>
                  <div style="clear:both;">holds if
                  <ul class="tight">
                    <li><m>T</m> has exactly one triple <m>t</m>.</li>
                    <li><m>t</m> has the predicate "<code>http://xmlns.com/foaf/0.1/givenName</code>"</li>
                  </ul></div>
                </div>
              </li>
              <li>
                <p>or <code class="function">satisfies(<m>value</m>, <span class="param">valueExpr</span>, <m>G</m>, <m>m</m>)</code>.</p>
                <div class="example">
                  <m><div style="float:left;">matches(</div><div style="float:left;">T,<br/>
                  <div class="inline json">
                    <pre>{ "type": "TripleConstraint", "inverse": true,
  "predicate": "http://purl.org/dc/elements/1.1/author",
  "valueExpr": "http://schema.example/IssueShape" }</pre></div>,<br/>
              m)</div>
                  </m>
                  <div style="clear:both;">holds if
                  <ul class="tight">
                    <li><m>T</m> has exactly one triple <m>t</m>.</li>
                    <li><m>t</m> has the predicate "<code>http://purl.org/dc/elements/1.1/author</code>"</li>
                    <li><m>t</m> has a subject <m>n2</m></li>
                    <li>The schema's <span class="param">shapes</span> maps "<code>http://schema.example/IssueShape</code>" to <m>se2</m></li>
                    <li><m class="function">satisfies(n2, se2, G, m)</m></li>
                  </ul></div>
                </div>
                <!--
                <p class="issue">[Editorial] The following is a more verbose description of the above. Which is preferred?</p>
                <div class="example">
                  For the schema<br/>
                  <div class="inline json">
                    <pre>{ "type": "Schema", "shapes": {
  "http://schema.example/UserShape": {
    "type": "Shape", "expression": {
      "type": "TripleConstraint", "inverse": true,
      "predicate": "http://purl.org/dc/elements/1.1/author",
      "valueExpr": {
        "type": "ShapeAnd", "shapeExprs": [
          { "type": "NodeConstraint", "nodeKind": "iri", "pattern": "http:.*" },
          "http://schema.example/IssueShape"
        ] } } },
  "http://schema.example/IssueShape": { "type": "Shape" } } }</pre>
                  </div><div style="clear:both;"></div>
                  <m><div style="float:left;">matches(</div><div style="float:left;">T,<br/>
                  <div class="inline json">
                    <pre>{ "type": "TripleConstraint", "inverse": true,
  "predicate": "http://purl.org/dc/elements/1.1/author",
  "valueExpr": { ‚Ä¶ } }</pre></div>,<br/>
              m)</div>
                  </m>
                  <div style="clear:both;">holds if
                  <ul class="tight">
                    <li><m>T</m> has exactly one triple <m>t</m>.</li>
                    <li><m>t</m> has the predicate "<code>http://purl.org/dc/elements/1.1/author</code>"</li>
                    <li><m>t</m> has a subject <m>n2</m></li>
                    <li>The schema's <span class="param">shapes</span> maps "<code>http://schema.example/IssueShape</code>" to <m>se2</m></li>
                    <li><m class="function">satisfies(n2, se2, G, m)</m></li>
                  </ul></div>
                </div>
                -->
              </li>
            </ul></li>
          </ul>
        </li>
        <li>
          <p id="matches-inclusion">
            <m>expr</m> is an <span class="jobjref"><a href="#dfn-inclusion" class="obj">inclusion</a></span> and <code class="function">satisfies(<m>value</m>, tripleExprWithId(<span class="param">inclusion</span>), <m>G</m>, <m>m</m>)</code>.<br/>
            The <code class="function">tripleExprWithId</code> function is defined in <a href="#inclusion-requirement">Inclusion Requirement</a> below.
          </p>
          <div class="example">
            For the schema<br/>
            <div class="inline json">
              <pre>{ "type": "Schema", "shapes": {
  "http://schema.example/EmployeeShape": {
    "type": "Shape", "expression": {
      "type": "EachOf", "expressions": [
        "http://schema.example/nameExpr",
        { "type": "TripleConstraint",
          "predicate": "http://schema.example/empID",
          "valueExpr": { "type": "NodeConstraint",
            "datatype": "http://www.w3.org/2001/XMLSchema#integer" } } ] } },
  "http://schema.example/PersonShape": {
    "type": "Shape", "expression": {
      "id": "http://schema.example/nameExpr",
      "type": "TripleConstraint",
      "predicate": "http://xmlns.com/foaf/0.1/name" } } } }</pre>
            </div><div style="clear:both;"></div>
            <m><div style="float:left;">matches(</div><div style="float:left;">T,<br/>
            <div class="inline json">
              <pre>"http://schema.example/PersonShape"</pre></div>,<br/>
              m)</div>
            </m>
            <div style="clear:both;">holds if
            <ul class="tight">
              <li>The schema has a shape <m>se2</m> with the <span class="param">id</span> "<code>http://schema.example/PersonShape</code>"</li>
              <li><m class="function">satisfies(n, se2, G, m)</m></li>
            </ul></div>
          </div>
        </li>
      </ul>
    </section>
      </section>

    <section id="schema-requirements">
      <h3>Schema Requirements</h3>
      <p>
        The semantics defined above assume two structural requirements beyond those imposed by the grammar of the abstract syntax.
        These ensure referential integrity and eliminate logical paradoxes such as those that arrise through the use of negation.
        These are not constraints expressed by the schema but instead those imposed on the schema.
      </p>
      

      <section id="shapeRef-requirement">
        <h4>ShapeRef Requirement</h4>
        <p>An <span class="jobjref"><a href="#dfn-shapeRef">shapeRef</a></span> MUST appear in the schema's <span class="param">shapes</span> map and the corresponding triple expression MUST be a <span class="jobjref"><a href="#dfn-Shape">Shape</a></span> with a <span class="param">shapeExpr</span>.
        The function <code>shapeExprWithId(<span class="param">shapeRef</span>)</code> returns the shape's <span class="param">shapeExpr</span>.
      </p>

      <div class="example">
        <p>
          Following are two valid shapeRefs:
        </p>
        <div class="repchoice">
          <pre class="json">{ "type":"Schema", "shapes": {
    "http://schema.example/PersonShape": {
      "type":"Shape", "expression": {
        "id": "http://schema.example/nameExpr",
        "type": "TripleConstraint",
        "predicate": "http://xmlns.com/foaf/0.1/name"
      } },
    "http://schema.example/EmployeeShape": { "type":"EachOf", "shapeExprs": [
        "http://schema.example/nameExpr",
        {
      "type":"Shape", "expression": { "type": "TripleConstraint",
          "predicate": "http://schema.example/employeeNumber" }
} ] } } }</pre>
          <pre class="shexc">                                                                             
    ex:PersonShape {
      foaf:name .
    }

    ex:EmployeeShape ex:PersonShape AND {
      ex:employeeNumber .
    }




          </pre>
        </div>
        <div class="repchoice">
          <pre class="json">{ "type":"Schema", "shapes": {
    "http://schema.example/PersonShape": {
      "type":"Shape", "expression": {
        "id": "http://schema.example/nameExpr",
        "type": "TripleConstraint",
        "predicate": "http://xmlns.com/foaf/0.1/name"
      } },
    "http://schema.example/EmployeeShape": {
      "type":"Shape", "expression": { "type": "TripleConstraint",
          "predicate": "http://schema.example/dependent",
          "valueExpr": "http://schema.example/PersonShape" } } } }</pre>
          <pre class="shexc">                                                                  
    ex:PersonShape {
      foaf:name .
    }



    ex:EmployeeShape {
      ex:dependent ex:PersonShape*
    }
          </pre>
        </div>
        <p>
          This shapeRef is invalid because there is no corresponding shape expression:
        </p>
        <div class="repchoice error">
          <pre class="json">{ "type":"Schema", "shapes": {
    "http://schema.example/S1": {
      "type":"Shape", "expression":
        "http://schema.example/MissingShapeExpr"
} } }</pre>
          <pre class="shexc">                                                
    S1 {
      &amp;MissingShapeExpr
    }
          </pre>
        </div>
        <p>This shapeRef is invalid because the referenced object is a triple expression instead of a shape expression:</p>
        <div class="repchoice error">
          <pre class="json">{ "type":"Schema", "shapes": {
    "http://schema.example/CustomerShape": {
      "type":"Shape", "expression": { "type": "TripleConstraint",
          "id": "http://schema.example/discountExpr",
          "predicate": "http://schema.example/discount" } },
    "http://schema.example/EmployeeShape": {
      "type":"Shape", "expression": { "type": "TripleConstraint",
        "predicate": "http://schema.example/contactFor",
        "valueExpr": "http://schema.example/CustomerShape"
} } } }</pre>
          <pre class="shexc">                                                                 
    ex:CustomerShape {
      $ex:discountExpr ex:discount .
    }

    ex:EmployeeShape {
      ex:contactFor @ex:CustomerShape
    }

          </pre>
        </div>
      </div>
      </section>

      <section id="inclusion-requirement">
        <h4>Inclusion Requirement</h4>
        <p>An <span class="jobjref"><a href="#dfn-inclusion">inclusion</a></span> MUST identify a triple expression in the schema.
        The function <code>tripleExprWithId(<span class="param">inclusion</span>)</code> returns the triple expression with the id <span class="param">inclusion</span>.
      </p>

      <div class="example">
        <p>
          Following is a valid inclusion:
        </p>
        <div class="repchoice">
          <pre class="json">{ "type":"Schema", "shapes": {
    "http://schema.example/PersonShape": {
      "type":"Shape", "expression": {
        "id": "http://schema.example/nameExpr",
        "type": "TripleConstraint",
        "predicate": "http://xmlns.com/foaf/0.1/name"
      } },
    "http://schema.example/EmployeeShape": {
      "type":"Shape", "expression": { "type":"EachOf", "shapeExprs": [
        "http://schema.example/nameExpr",
        { "type": "TripleConstraint",
          "predicate": "http://schema.example/employeeNumber" }
] } } } }</pre>
          <pre class="shexc">                                                                      
    ex:PersonShape {
      foaf:name .
    }



    ex:EmployeeShape {
      &amp;ex:PersonShape ;
      ex:employeeNumber .
    }

          </pre>
        </div>
        <p>
          This inclusion is invalid because there is no corresponding triple expression:
        </p>
        <div class="repchoice error">
          <pre class="json">{ "type":"Schema", "shapes": {
    "http://schema.example/S1": {
      "type":"Shape", "expression":
        "http://schema.example/missingTripleExpr"
} } }</pre>
          <pre class="shexc">                                                 
    S1 {
      &amp;missingTripleExpr
    }
          </pre>
        </div>
        <p>This inclusion is invalid because the referenced object is a shape expression instead of a triple expression:</p>
        <div class="repchoice error">
          <pre class="json">{ "type":"Schema", "shapes": {
    "http://schema.example/CustomerShape": {
      "type":"ShapeAnd", "shapeExprs": [ <span class="comment">‚Ä¶</span> ]
    },
    "http://schema.example/PreferredCustomerShape": {
      "type":"Shape", "expression": { "type":"EachOf", "expressions": [
        "http://schema.example/CustomerShape",
        { "type": "TripleConstraint",
          "predicate": "http://schema.example/discount" }
] } } } }</pre>
          <pre class="shexc">                                                                       
    ex:CustomerShape {
      <span class="comment">‚Ä¶</span>; <span class="comment">‚Ä¶</span>
    }
    ex:PreferredCustomerShape {
      &amp;ex:CustomerShape ;
      ex:discount .
    }

          </pre>
        </div>
      </div>
      </section>

      <section id="negation-requirement">
        <h4>Negation Requirement</h4>
        <p>
          A schema MUST NOT contain any shape expression <m>S</m> with negated references, either directly or transitively, to <m>S</m>.
        A reference to <m>S</m> is negated if it containes an odd number of nested negations.
        A nested negation is any of:
      </p>
      <ul>
        <li>
          <p>a <span class="param">shapeExpr</span> in a <span class="jobjref"><a href="#dfn-ShapeNot">ShapeNot</a></span></p>
          <div class="example">
            <p>
              This negated self-reference violates the negation requirement:
            </p>
            <div class="repchoice error">
              <pre class="json">{ "type": "Schema", "shapes": {
    "http://schema.example/#S":
    <span class="lookit">{ "type": "ShapeNot"></span>, "shapeExpr":
      "http://schema.example/#S"
<span class="lookit">}</span> } }</pre>
              <pre class="shexc">                                       
    ex:S <span class="lookit">NOT</span> @ex:S


                </pre>
              </div>
              <p>
                This negated, indirect self-reference violates the negation requirement:
              </p>
              <div class="repchoice error">
                <pre class="json">{ "type": "Schema", "shapes": {
    "http://schema.example/#S":
    { "type": "ShapeNot">, "shapeExpr":
      "http://schema.example/#T" },
    "http://schema.example/#T": "http://schema.example/#S"
} }</pre>
                <pre class="shexc">                                                          
    ex:S NOT @ex:T


    ex:T @ex:S
                </pre>
              </div>
              <p>
                This doubly-negated self-reference does not violate the negation requirement:
              </p>
              <div class="repchoice">
                <pre class="json">{ "type": "Schema", "shapes": {
    "http://schema.example/#S": {
      "type": <span class="lookit">"ShapeNot"</span>, "shapeExpr": {
        "type": "ShapeOr", "shapeExprs": [
          { "type": "NodeConstraint", "nodeKind": "iri" },
          { "type": <span class="lookit">"ShapeNot"</span>,
            "shapeExpr": "http://schema.example/#S" }
] } } } }</pre>
                <pre class="shexc">                                                          
    ex:S NOT (IRI OR NOT @ex:S)





                </pre>
              </div>
          </div>
        </li>
        <li>
          a <span class="param">valueExpr</span> in a <span class="jobjref"><a href="#dfn-TripleConstraint">TripleConstraint</a></span> with <span class="param">predicate</span> <m>p</m> inside a <span class="jobjref"><a href="#dfn-Shape">Shape</a></span> with <span class="param">extra</span> <m>p</m>
          <div class="example">
            <p>
              This self-reference on a predicate designated as <span class="param">extra</span> violates the negation requirement:
            </p>
            <div class="repchoice error">
              <pre class="json">{ "type": "Schema", "shapes":
  { "http://schema.example/#S":
    { "type": "Shape",
      "extra": [ <span class="lookit">"http://schema.example/#p"</span> ], "expression":
      { "type": "TripleConstraint",
        "predicate": <span class="lookit">"http://schema.example/#p"</span>,
        "valueExpr": "http://schema.example/#S"
} } } }</pre>
              <pre class="shexc">                                                            
  ex:S EXTRA ex:p {
    ex:p @ex:S
  }



              </pre>
            </div>
            <p>
              The same shape with a negated self-reference still violates the negation requirement because the reference occurs with a <span class="jobjref"><a href="#dfn-ShapeNot">ShapeNot</a></span>:
            </p>
            <div class="repchoice error">
              <pre class="json">{ "type": "Schema", "shapes": {
    "http://schema.example/#S": {
      "type": "Shape",
      "extra": [ "http://schema.example/#p" ],
      "expression": {
        "type": "TripleConstraint",
        "predicate": "http://schema.example/#p",
        "valueExpr": {
          "type": <span class="lookit">"ShapeNot"</span>, "shapeExpr": "http://schema.example/#S"
} } } } }</pre>
              <pre class="shexc">                                                                     
    ex:S EXTRA ex:p {
      ex:p NOT @ex:S
    }





              </pre>
            </div>
          </div>
        </li>
      </ul>
    </section>

    </section>

      <section id="semantic-actions">
        <h3>Semantic Actions</h3>
        <p>
          Semantic actions serve as an extension point for Shape Expressions.
          They appear in lists in <span class="jobjref"><a href="#dfn-Schema">Schema</a></span>'s <span class="param">startActs</span> and <span class="jobjref"><a href="#dfn-Shape">Shape</a></span>, <span class="jobjref"><a href="#dfn-OneOf">OneOf</a></span>, <span class="jobjref"><a href="#dfn-EachOf">EachOf</a></span> and <span class="jobjref"><a href="#dfn-TripleConstraint">TripleConstraint</a></span>'s <span class="param">semActs</span>.
        </p>
        <p>
          A semantic action is a tuple of an identifier and some optional code:
        </p>
        <div class="shexjTable">
          <table class="shexj">
  <tr class="obj"><th id="dfn-SemAct" class="obj">SemAct</th><td>{</td><td><span class="param">name</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">code</span>:<a class="trmref" href="#dfn-STRING">STRING</a>? }</td></tr>
          </table>
        </div>
        <section id="semantic-actions-semantics">
          <h4>Semantics</h4>
          <p>
            The evaluation <span id="semActsSatisfied" class="label">semActsSatisfied</span> on a list of <span class="jobjref"><a href="#dfn-SemAct">SemAct</a></span>s returns success or failure.
            The evaluation of an individual <span class="jobjref"><a href="#dfn-SemAct">SemAct</a></span> is implementation-dependent.
          </p>
        </section>
        <section id="semantic-actions-uses">
          <h4>Use - informative</h4>
          <p>
            A practical evaluation of a <span class="jobjref"><a href="#dfn-SemAct">SemAct</a></span> will provide access to some context.
            For instance, the <a href="http://shex.io/extensions/Test/#def">http://shex.io/extensions/Test/</a> extension requires access to the subject, predicate and object of a triple matching a <span class="jobjref"><a href="#dfn-TripleConstraint">TripleConstraint</a></span>.
            These are used in a <code>print</code> function.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Semantic Actions example 1</span></div>
            <div class="repchoice">
              <pre class="json">{ "type": "Schema", "shapes":{
    "http://a.example/S1": {
      "type": "Shape", "expression": {
        "type": "TripleConstraint", "predicate": "http://a.example/p1",
        "min": 1, "max": "*",
        "semActs": [
          { "type": "SemAct", "code": " print(s) ",
            "name": "http://shex.io/extensions/Test/" },
          { "type": "SemAct", "code": " print(o) ",
            "name": "http://shex.io/extensions/Test/" } ] } } } }
</pre>
              <pre class="shexc">                                                                       
    ex:S1 {
      ex:p1 .+ %Test:{ print(s) %} %Test:{ print(o) %}
    }





              </pre>
            </div>
            <pre class="data">&lt;http://a.example/n1&gt; &lt;http://a.example/p1&gt; &lt;http://a.example/o1&gt; .
&lt;http://a.example/n2&gt; &lt;http://a.example/p1&gt; "a", "b" .
&lt;http://a.example/n3&gt; &lt;http://a.example/p2&gt; &lt;http://a.example/o2&gt; .</pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>print arguments</th></tr>
              <tr class="pass"><td>&lt;S1&gt;</td><td>&lt;n1&gt;</td><td>pass</td><td>http://a.example/s1<br/>http://a.example/o1</td></tr>
              <tr class="pass"><td>&lt;S1&gt;</td><td>&lt;n2&gt;</td><td>pass</td><td>http://a.example/s1<br/>"a"<br/>http://a.example/s1<br/>"b"</td></tr>
              <tr class="fail"><td>&lt;S1&gt;</td><td>&lt;n3&gt;</td><td>fail</td><td class="noreason"></td></tr>
            </table>
          </div>
        </section>
      </section>

      <section id="annotations">
        <h3>Annotations</h3>
        <p>
          Annotations provide a format-independent way to provide additional information about elements in a schema.
          They appear in lists in <span class="jobjref"><a href="#dfn-Shape">Shape</a></span>, <span class="jobjref"><a href="#dfn-OneOf">OneOf</a></span>, <span class="jobjref"><a href="#dfn-EachOf">EachOf</a></span> and <span class="jobjref"><a href="#dfn-TripleConstraint">TripleConstraint</a></span>'s <span class="param">annotations</span>.
        </p>
        <div class="shexjTable">
          <table class="shexj">
  <tr class="obj"><th id="dfn-Annotation" class="obj">Annotation</th><td>{</td><td><span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">object</span>:<a class="nobref" href="#dfn-objectValue">objectValue</a> }</td></tr>
          </table>
        </div>
        <section id="annotations-semantics">
          <h4>Semantics - informative</h4>
          <p>
            Annotations do not affect whether a node conforms to some shape.
            Because they are part of the structure of the schema, they can be parsed in one ShEx format and emitted in that format or another.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Annotations example 1</span></div>
            <div class="repchoice">
              <pre class="json">{ "type": "Schema", "shapes":{
    "http://schema.example/IssueShape": {
      "type": "Shape", "expression": {
        "type": "TripleConstraint",
        "predicate": "http://schema.example/status",
        "annotations": [
           { "type": "Annotation",
             "predicate": "http://www.w3.org/2000/01/rdf-schema#comment",
             "object": "\"Represents reported software issues.\"" },
           { "type": "Annotation",
             "predicate": "http://www.w3.org/2000/01/rdf-schema#label",
             "object": "\"software issue\"" } ] } } }</pre>
              <pre class="shexc">                                                                         
    ex:IssueShape {
      ex:status .
          // rdfs:comment "Represents reported software issues."
          // rdfs:label "software issue"
    }




              </pre>
            </div>
          </div>
        </section>
    </section>

      <section id="validation-examples">
        <h3>Validation Examples</h3>
        <p>
          The following examples demonstrate proofs for validations in the form of a nested list of invocations of the evaluation functions defined above.
        </p>
        <section id="example-simple">
          <h4>Simple Examples</h4>
          <!--
              BASE <http://schema.example/>
              PREFIX ex: <http://schema.example/>
              PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
              PREFIX dc: <http://purl.org/dc/elements/1.1/>
              <IntConstraint> xsd:integer
          -->
          <div class="example">
              <span class="exsec">Schema:</span><br/>
              <pre class="line-labels">


<span class="lineno schema">S1</span>

</pre>
            <div class="inline repchoice">
              <pre class="json">{ "type": "Schema", "shapes":
  { "http://schema.example/IntConstraint":
    { "type": "NodeConstraint",
      "datatype": "http://www.w3.org/2001/XMLSchema#integer"
    } } }</pre>
              <pre class="shexc">                                                            

  ex:IntConstraint
    xsd:integer
              </pre>
            </div>
            <div style="clear:both;"></div>
<!--             Data:<br/>
            <pre class="line-labels">


<span class="lineno data">t1</span></pre>
            <div class="inline json">
              <pre>PREFIX ex: &lt;http://schema.example/&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
ex:someNode ex:somePredicate "30"^^xsd:integer .
</pre>
            </div>
            <div style="clear:both;"></div> -->
            <p>
              Here the shape identified by <code>http://schema.example/IntConstraint</code> is a shape expression consisting of a single <span class="jobjref"><a href="#dfn-NodeConstraint" class="obj">NodeConstraint</a></span>.
              Per <a href="#shape-expression-semantics">Shape Expression Semantics</a>, "30"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt; satisfies <span class="lineno schema">IntConstraint</span>.
            </p>
            <p>
              This document uses this nested tree convention to indicate that the dependency of an evaluation on those nested inside it.
              Nesting is expressed as indentation.
              Here, the evaluation of <m class="function">satisfies NodeConstraint ("30"^^xsd:integer, S1, G, m)</m> depends on <m class="function">satisfies2 NodeConstraint ("30"^^xsd:integer, S1)</m>.
            </p>
            <div class="validation"><span>Validate</span> <span>"30"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</span> as <span class="hljs-string">IntConstraint</span>:</div>
            <ul class="trace followup">
              <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("30"^^xsd:integer, <span class="lineno schema">S1</span>, G, m)
              <ul>
                <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("30"^^xsd:integer, <span class="lineno schema">S1</span>)</li>
              </ul></li>
            </ul>
          </div>

          <p class="leadup">
            Validating a shape requires evaluating it's triple expression as well as the variables and functions <m>neigh(G, n)</m>, <m>matched</m>, <m>remainder</m>, <m>outs</m>, <m>matchables</m> and <m>unmatchables</m>:<br/>
          </p>
          <div class="example">
            <!--
                BASE &lt;http://schema.example/&gt;
                PREFIX ex: &lt;http://schema.example/&gt;
                PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
                PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
                PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
                &lt;UserShape&gt; { ex:shoeSize . }
            -->
            <span class="exsec">Schema:</span><br/>
            <pre class="line-labels"> 

<span class="lineno schema">S1</span>
<span class="lineno schema">tc1</span>
</pre>
            <div class="inline repchoice">
              <pre class="json">{ "type": "Schema", "shapes": {
  "http://schema.example/UserShape":
  { "type": "Shape", "expression":
    { "type": "TripleConstraint",
      "predicate": "http://schema.example/shoeSize"
      } } } }</pre>
              <pre class="shexc">                                                   

  ex:UserShape {
    ex:shoeSize .
  }
              </pre>
            </div>
            <div style="clear:both;" class="exsec">Data:</div>
            <pre class="line-labels"> 

<span class="lineno data">t1</span></pre>
            <div class="inline json">
              <pre>BASE &lt;http://a.example/&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
&lt;Alice&gt; ex:shoeSize "30"^^xsd:integer .
</pre>
            </div>
            <div style="clear:both;" class="validation"><span>Validate</span> <span class="hljs-name">&lt;Alice&gt;</span> as <span class="hljs-string">http://schema.example/UserShape</span>:</div>
            <ul class="trace followup">
              <li>G = [<span class="lineno data">t1</span>] <span class="comment">The graph G consists of one triple.</span></li>
              <li><a href="#satisfies-Shape">satisfies Shape</a> (&lt;Alice&gt;, <span class="lineno schema">S1</span>, G, m)
              <ul>
                <li>neigh(G, &lt;Alice&gt;) = [<span class="lineno data">t1</span>] <span class="comment">/* The neighborhood around &lt;Alice&gt; consists of one triple. */</span></li>
                <li>matched = [<span class="lineno data">t1</span>] <span class="comment">/* That triple is matched in the nested evaluation. */</span></li>
                <li>remainder = √ò <span class="comment">/* The remainder is the empty set. */</span></li>
                <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t1</span>], <span class="lineno schema">tc1</span>, m)</li>
                <li>outs = [<span class="lineno data">t1</span>] <span class="comment">/* There is one arc out. */</span></li>
                <li>matchables = √ò <span class="comment">/* There are no remaining arcs out of &lt;Alice&gt; with predicates appearing in tc1. */</span></li>
                <li>unmatchables = √ò <span class="comment">/* There are no other arcs out of &lt;Alice&gt;. */</span></li>
                <li><span class="parameter">closed</span> is false <span class="comment">/* The <span class="jobjref"><a href="#dfn-Shape">Shape</a></span>'s closed paramater has a value of false. */</span></li>
              </ul>
              </li>
            </ul>
          </div>
            <p class="leadup">
              It is quite common that Shapes will constrain their nested TripleConstraints with NodeConstraints.
              Here is an example including that, extra triples and a closed shape:
            </p>
          <div class="example">
            <!--
                BASE <http://schema.example/>
                PREFIX ex: <http://schema.example/>
                PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
                PREFIX foaf: <http://xmlns.com/foaf/0.1/>
                PREFIX dc: <http://purl.org/dc/elements/1.1/>
                <UserShape> CLOSED EXTRA a {
                  a [ex:Teacher]
                }
            -->
            <span class="exsec">Schema:</span><br/>
            <pre class="line-labels"> 

<span class="lineno schema">S1</span>
<span class="lineno schema">tc1</span>



<span class="lineno schema">nc1</span>
</pre>
            <div class="inline repchoice">
              <pre class="json">{ "type": "Schema", "shapes": {
  "http://schema.example/UserShape":
  { "type": "Shape", "expression":
    "extra": ["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"],
    { "type": "TripleConstraint",
      "predicate": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "valueExpr":
      { "type": "NodeConstraint",
        "values": ["http://schema.example/Teacher"]
      } } } } }</pre>
              <pre class="shexc">                                                                     

  ex:UserShape EXTRA a {
    a



      [ex:Teacher]
  }
              </pre>
            </div>
            <div style="clear:both;" class="exsec">Data:</div>
            <pre class="line-labels"> 

<span class="lineno data">t1</span>
<span class="lineno data">t2</span>
<span class="lineno data">t3</span>
<span class="lineno data">t4</span>
<span class="lineno data">t5</span></pre>
            <div class="inline json">
              <pre>BASE &lt;http://a.example/&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
&lt;Alice&gt; ex:shoeSize "30"^^xsd:integer .
&lt;Alice&gt; a ex:Teacher .
&lt;Alice&gt; a ex:Person .
&lt;SomeHat&gt; ex:owner &lt;Alice&gt; .
&lt;TheMoon&gt; ex:madeOf &lt;GreenCheese&gt; .
</pre>
            </div>
            <div style="clear:both;" class="validation"><span>Validate</span> <span class="hljs-name">&lt;Alice&gt;</span> as <span class="hljs-string">http://schema.example/UserShape</span>:</div>
            <ul class="trace followup">
              <li>G = [<span class="lineno data">t1,t2,t3,t4,t5</span>]</li>
              <li><a href="#satisfies-Shape">satisfies Shape</a> (&lt;Alice&gt;, <span class="lineno schema">S1</span>, G, m)
              <ul>
                <li>neigh(G, &lt;Alice&gt;) = [<span class="lineno data">t1,t2,t3,t4</span>], matched = [<span class="lineno data">t2</span>], remainder = [<span class="lineno data">t1,t3</span>]</li>
                <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t2</span>], <span class="lineno schema">tc1</span>, m)
                <ul style="border-left:solid thin brown">
                  <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> (ex:Teacher, <span class="lineno schema">nc1</span>, G, m)
                  <ul>
                    <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> (ex:Teacher, <span class="lineno schema">nc1</span>)</li>
                </ul></li></ul></li>
                <li>outs = [<span class="lineno data">t1,t2,t3</span>]</li>
                <li>matchables = [<span class="lineno data">t3</span>], unmatchables = [<span class="lineno data">t1</span>], <span class="parameter">closed</span> is false</li>
              </ul>
              </li>
            </ul>
            <p>
              The non-empty matchables is permitted because the triple <code>t3</code> has a predicate which appears in the "extra" list: <span class="json">["http://schema.example/Teacher"]</span>.
            </p>
          </div>
        </section>

        <section id="example-disjunction">
          <h4>Disjunction Example</h4>
          <!--
              BASE <http://schema.example/>
              PREFIX ex: <http://schema.example/>
              PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
              PREFIX dc: <http://purl.org/dc/elements/1.1/>
              <UserShape> {
                foaf:name LITERAL | foaf:givenName LITERAL +; foaf:familyName LITERAL
              }
          -->
          <div class="example">
              <div class="exsec">Schema:</div><br/>
              <pre class="line-labels"> 

<span class="lineno schema">S1</span>
<span class="lineno schema">te1</span>
<span class="lineno schema">tc1</span>


<span class="lineno schema">nc1</span>
<span class="lineno schema">te2</span>
<span class="lineno schema">tc2</span>


<span class="lineno schema">nc2</span>
<span class="lineno schema">tc3</span>


<span class="lineno schema">nc3</span>
</pre>
            <div class="inline repchoice">
              <pre class="json">{ "type": "Schema", "shapes": {
  "http://schema.example/UserShape":
  { "type": "Shape", "expression":
     {"type": "OneOf", "expressions": [
        { "type": "TripleConstraint",
          "predicate": "http://xmlns.com/foaf/0.1/name",
          "valueExpr":
            { "type": "NodeConstraint", "nodeKind": "literal" } },
        { "type": "EachOf", "expressions": [
            { "type": "TripleConstraint", "min": 1, "max": "*" ,
              "predicate": "http://xmlns.com/foaf/0.1/givenName",
              "valueExpr":
                { "type": "NodeConstraint", "nodeKind": "literal" } },
            { "type": "TripleConstraint",
              "predicate": "http://xmlns.com/foaf/0.1/familyName",
              "valueExpr":
                { "type": "NodeConstraint", "nodeKind": "literal" } }
        ] }
     ] }
 } } }
</pre>
              <pre class="shexc">                                                                      
  ex:UserShape
    {
     (              <span class="comment"># extra ()s to clarify alignment with ShExJ</span>
      foaf:name


              LITERAL |
      (             <span class="comment"># extra ()s to clarify alignment with ShExJ</span>
       foaf:givenName


               LITERAL+ ;
       foaf:familyName


               LITERAL
      )
     )
    }
</pre>
            </div>
            <div style="clear:both;" class="exsec">Data:</div>
            <pre class="line-labels">


<span class="lineno data">t1</span>
<span class="lineno data">t2</span>
<span class="lineno data">t3</span>
<span class="lineno data">t4</span>
<span class="lineno data">t5</span>
<span class="lineno data">t6</span></pre>
            <div class="inline json">
              <pre>BASE &lt;http://a.example/&gt;
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
&lt;Alice&gt; foaf:givenName "Alice" .
&lt;Alice&gt; foaf:givenName "Malsenior" .
&lt;Alice&gt; foaf:familyName "Walker" .
&lt;Alice&gt; foaf:mbox &lt;mailto:alice@example.com&gt; .
&lt;Bob&gt; foaf:knows &lt;Alice&gt; .
&lt;Bob&gt; foaf:mbox &lt;mailto:bob@example.com&gt; .
</pre>
            </div>
            <div style="clear:both;"></div>
            <p class="leadup">Per <a href="#shape-expression-semantics">Shape Expression Semantics</a>, &lt;Alice&gt; satisfies <span class="lineno">S1</span> with the simple ShapeMap</p>
            <pre class="line-labels">m:</pre>
            <div class="inline json">
              <pre>{ "http://a.example/Alice": "http://a.example/UserShape }</pre>
            </div>
            <div style="clear:both;"></div>
            <p class="leadup followup">as seen in this validation.</p>
            <div class="validation"><span>Validate</span> <span class="hljs-name">&lt;Alice&gt;</span> as <span class="hljs-string">http://schema.example/UserShape</span>:</div>
            <ul class="trace followup">
              <li>G = [<span class="lineno data">t1,t2,t3,t4,t5,t6</span>]</li>
              <li><a href="#satisfies-Shape">satisfies Shape</a> (&lt;Alice&gt;, <span class="lineno">S1</span>, G, m)
              <ul>
                <li>neigh(G, &lt;Alice&gt;) = [<span class="lineno data">t1,t2,t3,t4,t5</span>], matched = [<span class="lineno data">t1,t2,t3</span>], remainder = [<span class="lineno data">t4,t5</span>]</li>
                <li><a href="#matches-OneOf">matches OneOf</a> ([<span class="lineno data">t1,t2,t3</span>], <span class="lineno schema">te1</span>, m)
                <ul style="border-left:solid thin brown">
                  <li><a href="#matches-EachOf">matches EachOf</a> ([<span class="lineno data">t1,t2,t3</span>], <span class="lineno schema">te2</span>, m)
                  <ul style="border-left:solid thin brown">
                    <li><a href="#matches-cardinality">matches cardinality</a> ([<span class="lineno data">t1,t2</span>], <span class="lineno schema">tc2</span>, m)
                    <ul style="border-left:solid thin brown">
                      <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t1</span>], <span class="lineno schema">tc2</span>, m)
                      <ul>
                        <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("Alice", <span class="lineno schema">nc2</span>, G, m)
                        <ul>
                          <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("Alice", <span class="lineno schema">nc2</span>)</li>
                      </ul></li></ul></li>
                      <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t2</span>], <span class="lineno schema">tc2</span>, m)
                      <ul>
                        <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("Malsenior", <span class="lineno schema">nc2</span>, G, m)
                        <ul>
                          <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("Malsenior", <span class="lineno schema">nc2</span>)</li>
                      </ul></li></ul></li>
                    </ul></li>
                    <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t3</span>], <span class="lineno schema">tc3</span>, m)
                    <ul>
                      <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("Walker", <span class="lineno schema">nc3</span>, G, m)
                      <ul>
                        <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("Walker", <span class="lineno schema">nc3</span>)</li>
                </ul></li></ul></li></ul></li></ul></li>
                <li>outs = [<span class="lineno data">t4</span>] <span class="comment">/* <span class="lineno data">t5</span> is in <m>ArcsIn(G, &lt;Alice&gt;)></m>, <span class="lineno data">t6</span> is not in <m>neigh(G, &lt;Alice&gt;)></m>. */</span></li>
                <li>matchables = √ò, unmatchables = [<span class="lineno data">t5</span>], <span class="parameter">closed</span> is false</li>
              </ul>
              </li>
            </ul>

            <p class="leadup">
              Replacing triples 1-3 with a single foaf:name property will also satisfy the schema.
            </p>
            <div class="exsec">Data:</div>
            <pre class="line-labels">


<span class="lineno data">t4</span>
<span class="lineno data">t5</span>
<span class="lineno data">t6</span>
<span class="lineno data">t7</span></pre>
            <div class="inline json">
              <pre>BASE &lt;http://a.example/&gt;
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
&lt;Alice&gt; foaf:mbox &lt;mailto:alice@example.com&gt; .
&lt;Bob&gt; foaf:knows &lt;Alice&gt; .
&lt;Bob&gt; foaf:mbox &lt;mailto:bob@example.com&gt; .
&lt;Alice&gt; foaf:name "Alice Malsenior Walker" .
</pre>
            </div>
            <div style="clear:both;" class="validation"><span>Validate</span> <span class="hljs-name">&lt;Alice&gt;</span> as <span class="hljs-string">http://schema.example/UserShape</span>:</div>
            <ul class="trace followup">
              <li>G = [<span class="lineno data">t4,t5,t6,t7</span>]</li>
              <li><a href="#satisfies-Shape">satisfies Shape</a> (&lt;Alice&gt;, <span class="lineno schema">S1</span>, G, m)
              <ul>
                <li>neigh(G, &lt;Alice&gt;) = [<span class="lineno data">t4,t5,t7</span>], matched = [<span class="lineno data">t7</span>], remainder = [<span class="lineno data">t4,t5</span>]</li>
                <li><a href="#matches-OneOf">matches OneOf</a> ([<span class="lineno data">t7</span>], <span class="lineno schema">te1</span>, m)
                <ul style="border-left:solid thin brown">
                  <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t7</span>], <span class="lineno schema">tc1</span>, m)
                  <ul>
                    <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("Walker", <span class="lineno schema">nc3</span>, G, m)
                    <ul>
                      <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("Walker", <span class="lineno schema">nc3</span>)</li>
                </ul></li></ul></li></ul></li>
                <li>outs = [<span class="lineno data">t4</span>]</li>
                <li>matchables = √ò, unmatchables = [<span class="lineno data">t5</span>], <span class="parameter">closed</span> is false</li>
              </ul>
              </li>
            </ul>

            <p class="leadup">
              Any mixure of <code>foaf:name</code> with <code>foaf:givenName</code> or <code>foaf:familyName</code> will fail to satisfy the schema as there will be a matchable triple <span class="lineno data">t3</span> that's not used in the triple expression <span class="lineno schema">te1</span>.
            </p>
            <div class="exsec">Data:</div>
            <pre class="line-labels">


<span class="lineno data">t3</span>
<span class="lineno data">t4</span>
<span class="lineno data">t5</span>
<span class="lineno data">t6</span>
<span class="lineno data">t7</span></pre>
            <div class="inline json">
              <pre>BASE &lt;http://a.example/&gt;
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
<span class="fail">&lt;Alice&gt; foaf:familyName "Walker" .</span>
&lt;Alice&gt; foaf:mbox &lt;mailto:alice@example.com&gt; .
&lt;Bob&gt; foaf:knows &lt;Alice&gt; .
&lt;Bob&gt; foaf:mbox &lt;mailto:bob@example.com&gt; .
&lt;Alice&gt; foaf:name "Alice Malsenior Walker" .
</pre>
            </div>
            <div style="clear:both;" class="validation"><span>Validate</span> <span class="hljs-name">&lt;Alice&gt;</span> as <span class="hljs-string">http://schema.example/UserShape</span>:</div>
            <ul class="trace followup">
              <li>G = [<span class="lineno data">t4,t5,t6,t7</span>]</li>
              <li><span class="fail"><a href="#satisfies-Shape">satisfies Shape</a> (&lt;Alice&gt;, <span class="lineno schema">S1</span>, G, m)</span>
              <ul>
                <li>neigh(G, &lt;Alice&gt;) = [<span class="lineno data">t4,t5,t7</span>], matched = [<span class="lineno data">t7</span>], remainder = [<span class="lineno data">t4,t5</span>]</li>
                <li><a href="#matches-OneOf">matches OneOf</a> ([<span class="lineno data">t7</span>], <span class="lineno schema">te1</span>, m)
                <ul style="border-left:solid thin brown">
                  <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t7</span>], <span class="lineno schema">tc1</span>, m)
                  <ul>
                    <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("Walker", <span class="lineno schema">nc3</span>, G, m)
                    <ul>
                      <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("Walker", <span class="lineno schema">nc3</span>)</li>
                </ul></li></ul></li></ul></li>
                <li>outs = [<span class="lineno data">t4</span>]</li>
                <li><span class="fail">matchables = [<span class="lineno data">t3</span>]</span>, unmatchables = [<span class="lineno data">t5</span>], <span class="parameter">closed</span> is false</li>
              </ul>
              </li>
            </ul>

            <p class="leadup">
              Adding a <code>foaf:familyName</code> to <m><span class="lineno schema">S1</span></m>'s <span class="param">extra</span> would allow this graph to satisfy the schema.
            </p>
              <pre class="line-labels"> 

<span class="lineno schema">S1</span>
</pre>
            <div class="inline json">
              <pre>{ "type": "Schema", "shapes": {
  "http://schema.example/UserShape":
  { "type": "Shape", "extra": ["http://xmlns.com/foaf/0.1/familyName"] ‚Ä¶
   } } }</pre>
            </div>
            <div style="clear:both;"></div>

            <p class="leadup">
              Closing <m><span class="lineno schema">S1</span></m> would also cause a validation failure if <m>unmatchables</m> were not empty:
            </p>
              <pre class="line-labels"> 

<span class="lineno schema">S1</span>
</pre>
            <div class="inline json">
              <pre>{ "type": "Schema", "shapes": {
  "http://schema.example/UserShape":
  { "type": "Shape", "closed": true ‚Ä¶
   } } }</pre>
            </div>
            <div style="clear:both;"></div>
            <ul class="trace followup">
              <li>G = [<span class="lineno data">t4,t5,t6,t7</span>]</li>
              <li><span class="fail"><a href="#satisfies-Shape">satisfies Shape</a> (&lt;Alice&gt;, <span class="lineno schema">S1</span>, G, m)</span>
              <ul>
                <li>‚Ä¶</li>
                <li><span class="fail">unmatchables = [<span class="lineno data">t5</span>], <span class="parameter">closed</span> is true</span></li>
              </ul>
              </li>
            </ul>

          </div>
        </section>

        <section id="example-dependent-shape">
          <h4>Dependent Shape Example</h4>
          <!--
BASE <http://schema.example/>
PREFIX ex: <http://schema.example/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
<IssueShape> {
  ex:reproducedBy @<TesterShape>;
}
<TesterShape> {
  ex:role [ex:testingRole]
}
          -->
          <div class="example">
              <div class="exsec">Schema:</div>
              <pre class="line-labels"> 

<span class="lineno schema">S1</span>
<span class="lineno schema">tc1</span>


<span class="lineno schema">nc1</span>


<span class="lineno schema">S2</span>
<span class="lineno schema">tc2</span>


<span class="lineno schema">nc2</span>


</pre>
            <div class="inline json">
              <pre>{ "type": "Schema", "shapes": {
  "http://schema.example/IssueShape":
  { "type": "Shape", "expression":
    { "type": "TripleConstraint",
      "predicate": "http://schema.example/reproducedBy",
      "valueExpr":
      "http://schema.example/TesterShape" } },
  "http://schema.example/TesterShape":
  { "type": "Shape", "expression":
    { "type": "TripleConstraint",
      "predicate": "http://schema.example/role",
      "valueExpr":
      { "type": "NodeConstraint",
        "values": [ "http://schema.example/testingRole" ] } } }
  } }</pre>
            </div>
            <div style="clear:both;" class="exsec">Data:</div>
            <pre class="line-labels">

<span class="lineno data">t1</span>
<span class="lineno data">t2</span></pre>
            <div class="inline json">
              <pre>PREFIX ex: &lt;http://schema.example/&gt;
PREFIX inst: &lt;http://inst.example/&gt;
inst:Issue1 ex:reproducedBy inst:Tester2 .
inst:Tester2 ex:role ex:testingRole .</pre>
            </div>
            <div style="clear:both;"></div>
            <p class="leadup">inst:Issue1 satisfies <span class="lineno schema">S1</span> with the ShapeMap</p>
            <pre class="line-labels">m:</pre>
            <div class="inline json">
              <pre>{ "http://inst.example/Issue1": "http://schema.example/IssueShape",
  "http://inst.example/Tester2": "http://schema.example/TesterShape",
  "http://inst.example/Testgrammer23": "http://schema.example/ProgrammerShape" }</pre>
            </div>
            <div style="clear:both;" class="validation"><span>Validate</span> <span>inst:Issue1</span> as <span class="hljs-string">http://schema.example/IssueShape</span>:</div>
            <p class="leadup followup">as seen in this evaluation:</p>
            <ul class="trace followup">
              <li>G = [<span class="lineno data">t1</span>]</li>
              <li><a href="#satisfies-Shape">satisfies Shape</a> (inst:Issue1, <span class="lineno schema">S1</span>, G, m)
              <ul>
                <li>neigh(G, inst:Issue1) = [<span class="lineno data">t1,t2</span>], matched = [<span class="lineno data">t1,t2</span>], remainder = √ò</li>
                  <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t1</span>], <span class="lineno schema">tc1</span>, m)
                  <ul style="border-left:solid thin brown">
                    <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> (inst:Tester2, <span class="lineno schema">nc1</span>, G, m)
                    <ul>
                      <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> (inst:Tester2, <span class="lineno schema">nc1</span>)
                      <ul>
                        <li><a href="#satisfies-Shape">satisfies Shape</a> (inst:Tester2. <span class="lineno schema">S2</span>, G, m)
                        <ul>
                          <li>neigh(G, inst:Tester2) = [<span class="lineno data">t2</span>], matched = [<span class="lineno data">t2</span>], remainder = √ò</li>
                          <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t2</span>], <span class="lineno schema">tc2</span>, m)
                          <ul style="border-left:solid thin brown">
                            <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> (ex:testingRole, <span class="lineno schema">nc2</span>, G, m)
                            <ul>
                              <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> (ex:testingRole, <span class="lineno schema">nc2</span>)</li>
                        </ul></li></ul></li>
                          <li>outs = √ò</li>
                          <li>matchables = √ò, unmatchables = √ò, closed is false</li>
                  </ul></li></ul></li></ul></li></ul></li>
                <li>outs = √ò</li>
                <li>matchables = √ò, unmatchables = √ò, closed is false</li>
              </ul>
              </li>
            </ul>
            <div style="clear:both;"></div>
          </div>
        </section>

        <section id="example-recursion">
          <h4>Recursion Example</h4>
          <!--
BASE <http://schema.example/>
PREFIX ex: <http://schema.example/>
<IssueShape> {
  ex:related @<IssueShape>*
}
          -->
          <div class="example">
              <div class="exsec">Schema:</div>
              <pre class="line-labels"> 

<span class="lineno schema">S1</span>
<span class="lineno schema">tc1</span>


<span class="lineno schema">nc1</span>

</pre>
            <div class="inline json">
              <pre>{ "type": "Schema", "shapes": {
  "http://schema.example/IssueShape":
  { "type": "Shape", "expression":
    { "type": "TripleConstraint", "min": 0, "max": "*",
      "predicate": "http://schema.example/related",
      "valueExpr":
      "http://schema.example/IssueShape"
    } } } }</pre>
            </div>
            <div style="clear:both;" class="exsec">Data:</div>
            <pre class="line-labels"> 

<span class="lineno data">t1</span>
<span class="lineno data">t2</span>
<span class="lineno data">t3</span></pre>
            <div class="inline json">
              <pre>PREFIX ex: &lt;http://schema.example/&gt;
PREFIX inst: &lt;http://inst.example/&gt;
inst:Issue1 ex:related inst:Issue2 .
inst:Issue2 ex:related inst:Issue3 .
inst:Issue3 ex:related inst:Issue1 .</pre>
            </div>
            <div style="clear:both;"></div>
            <p class="leadup">inst:Issue1 satisfies <span class="lineno schema">S1</span> with the ShapeMap</p>
            <pre class="line-labels">m:</pre>
            <div class="inline json">
              <pre>{ "http://inst.example/Issue1": "http://schema.example/IssueShape",
  "http://inst.example/Issue2": "http://schema.example/IssueShape",
  "http://inst.example/Issue3": "http://schema.example/IssueShape" }</pre>
            </div>
            <div style="clear:both;" class="validation"><span>Validate</span> <span>inst:Issue1</span> as <span class="hljs-string">http://schema.example/IssueShape</span>:</div>
            <p class="leadup followup">as seen in this evaluation:</p>
            <ul class="trace followup">
              <li>G = [<span class="lineno data">t1,t2,t3</span>]</li>
              <li><a href="#satisfies-Shape">satisfies Shape</a> (inst:Issue1, <span class="lineno schema">S1</span>, G, m)
              <ul>
                <li>neigh(G, inst:Issue1) = [<span class="lineno data">t1</span>], matched = [<span class="lineno data">t1</span>], remainder = √ò</li>
                <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t1</span>], <span class="lineno schema">tc1</span>, m)
                <ul style="border-left:solid thin brown">
                  <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> (inst:Issue2, <span class="lineno schema">nc1</span>, G, m)
                  <ul>
                    <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> (inst:Issue2, <span class="lineno schema">nc1</span>)
                    <ul>
                      <li><a href="#satisfies-Shape">satisfies Shape</a> (inst:Issue2. <span class="lineno schema">S2</span>, G, m)
                      <ul>
                        <li>neigh(G, inst:Issue2) = [<span class="lineno data">t3</span>], matched = [<span class="lineno data">t3</span>], remainder = √ò</li>
                        <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t3</span>], <span class="lineno schema">tc3</span>, m)
                        <ul style="border-left:solid thin brown">
                          <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> (inst:Issue3, <span class="lineno schema">nc3</span>, G, m)
                          <ul>
                            <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> (inst:Issue3, <span class="lineno schema">nc3</span>)
                            <ul>
                              <li><a href="#satisfies-Shape">satisfies Shape</a> (inst:Issue3. <span class="lineno schema">S2</span>, G, m)
                              <ul>
                                <li>neigh(G, inst:Issue3) = [<span class="lineno data">t3</span>], matched = [<span class="lineno data">t3</span>], remainder = √ò</li>
                                <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t3</span>], <span class="lineno schema">tc3</span>, m)
                                <ul style="border-left:solid thin brown">
                                  <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> (inst:Issue1, <span class="lineno schema">nc3</span>, G, m)
                                  <ul>
                                    <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> (inst:Issue1, <span class="lineno schema">nc3</span>)<br/>
                                    This is known to be true or the initial typing would not be satisfied.</li>
                                </ul></li></ul></li>
                                <li>outs = √ò</li>
                                <li>matchables = √ò, unmatchables = √ò, closed is false</li>
                            </ul></li></ul></li>
                        </ul></li></ul></li>
                        <li>outs = √ò</li>
                        <li>matchables = √ò, unmatchables = √ò, closed is false</li>
                </ul></li></ul></li></ul></li></ul></li>
                <li>outs = √ò</li>
                <li>matchables = √ò, unmatchables = √ò, closed is false</li>
              </ul>
              </li>
            </ul>
            <div style="clear:both;"></div>
          </div>
        </section>

        <section id="example-simple-repeated-property">
          <h4>Simple Repeated Property Examples</h4>
          <!--
              BASE <http://schema.example/>
              PREFIX ex: <http://schema.example/>
              PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
              PREFIX dc: <http://purl.org/dc/elements/1.1/>
              <S1> {
                ex:val ["a" "b" "c"]+;
                ex:val ["b" "c" "d"]+
              }
          -->
          <div class="example">
              <div class="exsec">Schema:</div>
              <pre class="line-labels"> 

<span class="lineno schema">S1</span>
<span class="lineno schema">te1</span>
<span class="lineno schema">tc1</span>


<span class="lineno schema">nc1</span>

<span class="lineno schema">tc2</span>


<span class="lineno schema">nc2</span>

</pre>
            <div class="inline json">
              <pre>{ "type": "Schema", "shapes": {
    "http://schema.example/TestResultsShape":
    { "type": "Shape", "expression": {
        "type": "EachOf", "expressions": [
          { "type": "TripleConstraint", "min": 1, "max": "*",
            "predicate": "http://schema.example/val",
            "valueExpr":
            { "type": "NodeConstraint",
              "values": [ "\"a\"", "\"b\"", "\"c\"" ] } },
          { "type": "TripleConstraint", "min": 1, "max": "*",
            "predicate": "http://schema.example/val",
            "valueExpr":
            { "type": "NodeConstraint",
              "values": [ "\"b\"", "\"c\"", "\"d\"" ] } }
        ] } } } }</pre>
            </div>
            <div style="clear:both;" class="exsec">Data:</div>
            <pre class="line-labels">


<span class="lineno data">t1</span>
<span class="lineno data">t2</span>
<span class="lineno data">t3</span>
<span class="lineno data">t4</span></pre>
            <div class="inline json">
              <pre>BASE &lt;http://a.example/&gt;
PREFIX ex: &lt;http://schema.example/&gt;
&lt;s&gt; ex:val "a" .
&lt;s&gt; ex:val "b" .
&lt;s&gt; ex:val "c" .
&lt;s&gt; ex:val "d" .</pre>
            </div>
            <div style="clear:both;"></div>
            <p class="leadup">&lt;s&gt; satisfies <span class="lineno schema">S1</span> with:</p>
            <pre class="line-labels">m:</pre>
            <div class="inline json">
              <pre>{ "http://a.example/s": "http://a.example/S1 }</pre>
            </div>
            <div style="clear:both;" class="validation"><span>Validate</span> <span class="hljs-name">&lt;s&gt;</span> as <span class="hljs-string">http://schema.example/TestResultShape</span>:</div>
            <p class="leadup followup">If <m><span class="lineno schema">tc1</span></m> consumes as many triples as it can, it consumes three and <m><span class="lineno schema">tc2</span></m> consumes one:</p>
            <ul class="trace followup">
              <li>G = [<span class="lineno data">t1,t2,t3,t4</span>]</li>
              <li><a href="#satisfies-Shape">satisfies Shape</a> (&lt;s&gt;, <span class="lineno schema">S1</span>, G, m)
              <ul>
                <li>neigh(G, &lt;s&gt;) = [<span class="lineno data">t1,t2,t3,t4</span>], matched = [<span class="lineno data">t1,t2,t3,t4</span>], remainder = √ò</li>
                <li><a href="#matches-EachOf">matches EachOf</a> ([<span class="lineno data">t1,t2,t3,t4</span>], <span class="lineno schema">te1</span>, m)
                <ul style="border-left:solid thin brown">
                  <li><a href="#matches-cardinality">matches cardinality</a> ([<span class="lineno data">t1,t2,t3</span>], <span class="lineno schema">tc1</span>, m)
                  <ul style="border-left:solid thin brown">
                    <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t1</span>], <span class="lineno schema">tc1</span>, m)
                    <ul>
                      <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("a", <span class="lineno schema">nc1</span>, G, m)
                      <ul>
                        <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("a", <span class="lineno schema">nc1</span>)</li>
                    </ul></li></ul></li>
                    <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t2</span>], <span class="lineno schema">tc1</span>, m)
                    <ul>
                      <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("b", <span class="lineno schema">nc1</span>, G, m)
                      <ul>
                        <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("b", <span class="lineno schema">nc1</span>)</li>
                    </ul></li></ul></li>
                    <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t3</span>], <span class="lineno schema">tc1</span>, m)
                    <ul>
                      <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("c", <span class="lineno schema">nc1</span>, G, m)
                      <ul>
                        <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("c", <span class="lineno schema">nc1</span>)</li>
                    </ul></li></ul></li>
                  </ul></li>
                  <li><a href="#matches-cardinality">matches cardinality</a> ([<span class="lineno data">t4</span>], <span class="lineno schema">tc2</span>, m)
                  <ul style="border-left:solid thin brown">
                    <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t4</span>], <span class="lineno schema">tc2</span>, m)
                    <ul>
                      <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("d", <span class="lineno schema">nc2</span>, G, m)
                      <ul>
                        <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("d", <span class="lineno schema">nc2</span>)</li>
                    </ul></li></ul></li>
                  </ul></li>
                </ul></li>
                <li>outs = √ò</li>
                <li>matchables = √ò, unmatchables = √ò, <span class="parameter">closed</span> is false</li>
              </ul>
              </li>
            </ul>
            <div style="clear:both;"></div>

            <p class="leadup">If we eliminate <m><span class="lineno data">t4</span></m>, either <m><span class="lineno data">t2</span></m> or <m><span class="lineno data">t3</span></m> must be allocated to <m><span class="lineno schema">tc2</span></m>:</p>
            <ul class="trace followup">
              <li>G = [<span class="lineno data">t1,t2,t3</span>]</li>
              <li><a href="#satisfies-Shape">satisfies Shape</a> (&lt;Alice&gt;, <span class="lineno schema">S1</span>, G, m)
              <ul>
                <li>neigh(G, &lt;Alice&gt;) = [<span class="lineno data">t1,t2,t3</span>], matched = [<span class="lineno data">t1,t2,t3</span>], remainder = √ò</li>
                <li><a href="#matches-EachOf">matches EachOf</a> ([<span class="lineno data">t1,t2,t3</span>], <span class="lineno schema">te1</span>, m)
                <ul style="border-left:solid thin brown">
                  <li><a href="#matches-cardinality">matches cardinality</a> ([<span class="lineno data">t1,t2</span>], <span class="lineno schema">tc1</span>, m)
                  <ul style="border-left:solid thin brown">
                    <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t1</span>], <span class="lineno schema">tc1</span>, m)
                    <ul>
                      <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("a", <span class="lineno schema">nc1</span>, G, m)
                      <ul>
                        <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("a", <span class="lineno schema">nc1</span>)</li>
                    </ul></li></ul></li>
                    <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t2</span>], <span class="lineno schema">tc1</span>, m)
                    <ul>
                      <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("b", <span class="lineno schema">nc1</span>, G, m)
                      <ul>
                        <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("b", <span class="lineno schema">nc1</span>)</li>
                    </ul></li></ul></li>
                  </ul></li>
                  <li><a href="#matches-cardinality">matches cardinality</a> ([<span class="lineno data">t3</span>], <span class="lineno schema">tc2</span>, m)
                  <ul style="border-left:solid thin brown">
                    <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t3</span>], <span class="lineno schema">tc2</span>, m)
                    <ul>
                      <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> ("d", <span class="lineno schema">nc2</span>, G, m)
                      <ul>
                        <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> ("d", <span class="lineno schema">nc2</span>)</li>
                    </ul></li></ul></li>
                  </ul></li>
                </ul></li>
                <li>outs = √ò</li>
                <li>matchables = √ò, unmatchables = √ò, <span class="parameter">closed</span> is false</li>
              </ul>
              </li>
            </ul>
            <div style="clear:both;"></div>
          </div>
        </section>

        <section id="example-repeated-property-with-dependent-shapes">
          <h4>Repeated Property With Dependent Shapes Example</h4>
          <!--
BASE <http://schema.example/>
PREFIX ex: <http://schema.example/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
<IssueShape> {
  ex:reproducedBy @<TesterShape>;
  ex:reproducedBy @<ProgrammerShape>
}
<TesterShape> {          
  ex:role [ex:testingRole]
}                         

<ProgrammerShape> {                      
  ex:department [ex:ProgrammingDepartment]
}
          -->
          <div class="example">
              <div class="exsec">Schema:</div>
              <pre class="line-labels"> 

<span class="lineno schema">S1</span>
<span class="lineno schema">te1</span>
<span class="lineno schema">tc1</span>


<span class="lineno schema">nc1</span>

<span class="lineno schema">tc2</span>


<span class="lineno schema">nc2</span>



<span class="lineno schema">S2</span>
<span class="lineno schema">tc3</span>


<span class="lineno schema">nc3</span>


<span class="lineno schema">S3</span>
<span class="lineno schema">tc4</span>


<span class="lineno schema">nc4</span>
</pre>
            <div class="inline json">
              <pre>{ "type": "Schema", "shapes": {
  "http://schema.example/IssueShape":
  { "type": "Shape", "expression":
    { "type": "EachOf", "expressions": [
        { "type": "TripleConstraint",
          "predicate": "http://schema.example/reproducedBy",
          "valueExpr":
          "http://schema.example/TesterShape" },
        { "type": "TripleConstraint",
          "predicate": "http://schema.example/reproducedBy",
          "valueExpr":
          "http://schema.example/ProgrammerShape" }
      ] } },
  "http://schema.example/TesterShape":
  { "type": "Shape", "expression":
    { "type": "TripleConstraint",
      "predicate": "http://schema.example/role",
      "valueExpr":
      { "type": "NodeConstraint",
        "values": [ "http://schema.example/testingRole" ] } } },
  "http://schema.example/ProgrammerShape":
  { "type": "Shape", "expression":
    { "type": "TripleConstraint",
      "predicate": "http://schema.example/department",
      "valueExpr":
      { "type": "NodeConstraint",
        "values": [ "http://schema.example/ProgrammingDepartment" ] } } }
  } }</pre>
            </div>
            <div style="clear:both;" class="exsec">Data:</div>
            <pre class="line-labels"> 


<span class="lineno data">t1</span>
<span class="lineno data">t2</span>


<span class="lineno data">t3</span>


<span class="lineno data">t4</span>
<span class="lineno data">t5</span></pre>
            <div class="inline json">
              <pre>PREFIX ex: &lt;http://schema.example/&gt;
PREFIX inst: &lt;http://inst.example/&gt;
inst:Issue1
  ex:reproducedBy inst:Tester2 ;
  ex:reproducedBy inst:Testgrammer23 .

inst:Tester2              
  ex:role ex:testingRole .

inst:Testgrammer23                        
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .</pre>
            </div>
            <div style="clear:both;"></div>
            <p class="leadup">inst:Issue1 satisfies <span class="lineno schema">S1</span> with the ShapeMap</p>
            <pre class="line-labels">m:</pre>
            <div class="inline json">
              <pre>{ "http://inst.example/Issue1": "http://schema.example/IssueShape",
  "http://inst.example/Tester2": "http://schema.example/TesterShape",
  "http://inst.example/Testgrammer23": "http://schema.example/ProgrammerShape" }</pre>
            </div>
            <div style="clear:both;" class="validation"><span>Validate</span> <span>inst:Issue1</span> as <span class="hljs-string">http://schema.example/IssueShape</span>:</div>
            <p class="leadup followup">as seen in this evaluation:</p>
            <ul class="trace followup">
              <li>G = [<span class="lineno data">t1,t2,t3,t4,t5</span>]</li>
              <li><a href="#satisfies-Shape">satisfies Shape</a> (inst:Issue1, <span class="lineno schema">S1</span>, G, m)
              <ul>
                <li>neigh(G, inst:Issue1) = [<span class="lineno data">t1,t2</span>], matched = [<span class="lineno data">t1,t2</span>], remainder = √ò</li>
                <li><a href="#matches-EachOf">matches EachOf</a> ([<span class="lineno data">t1,t2</span>], <span class="lineno schema">te1</span>, m)
                <ul style="border-left:solid thin brown">
                  <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t1</span>], <span class="lineno schema">tc1</span>, m)
                  <ul>
                    <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> (inst:Tester2, <span class="lineno schema">nc1</span>, G, m)
                    <ul>
                      <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> (inst:Tester2, <span class="lineno schema">nc1</span>)
                      <ul>
                        <li><a href="#satisfies-Shape">satisfies Shape</a> (inst:Tester2. <span class="lineno schema">S2</span>, G, m)
                        <ul>
                          <li>neigh(G, inst:Tester2) = [<span class="lineno data">t3</span>], matched = [<span class="lineno data">t3</span>], remainder = √ò</li>
                          <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t3</span>], <span class="lineno schema">tc3</span>, m)
                          <ul style="border-left:solid thin brown">
                            <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> (ex:testingRole, <span class="lineno schema">nc3</span>, G, m)
                            <ul>
                              <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> (ex:testingRole, <span class="lineno schema">nc3</span>)</li>
                        </ul></li></ul></li>
                          <li>outs = √ò</li>
                          <li>matchables = √ò, unmatchables = √ò, closed is false</li>
                  </ul></li></ul></li></ul></li></ul></li>
                  <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t2</span>], <span class="lineno schema">tc1</span>, m)
                  <ul>
                    <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> (inst:Testgrammer23, <span class="lineno schema">nc2</span>, G, m)
                    <ul>
                      <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> (inst:Testgrammer23, <span class="lineno schema">nc2</span>)
                      <ul>
                        <li><a href="#satisfies-Shape">satisfies Shape</a> (inst:Testgrammer23. <span class="lineno schema">S3</span>, G, m)
                        <ul>
                          <li>neigh(G, inst:Testgrammer23) = [<span class="lineno data">t5</span>], matched = [<span class="lineno data">t5</span>], remainder = √ò</li>
                          <li><a href="#matches-TripleConstraint">matches TripleConstraint</a> ([<span class="lineno data">t5</span>], <span class="lineno schema">tc3</span>, m)
                          <ul style="border-left:solid thin brown">
                            <li><a href="#satisfies-NodeConstraint">satisfies NodeConstraint</a> (ex:testingRole, <span class="lineno schema">nc4</span>, G, m)
                            <ul>
                              <li><a href="#satisfies2-NodeConstraint">satisfies2 NodeConstraint</a> (ex:testingRole, <span class="lineno schema">nc4</span>)</li>
                          </ul></li></ul></li>
                          <li>outs = √ò</li>
                          <li>matchables = √ò, unmatchables = √ò, closed is false</li>
                  </ul></li></ul></li></ul></li></ul></li>
                </ul></li>
                <li>outs = √ò</li>
                <li>matchables = √ò, unmatchables = √ò, closed is false</li>
              </ul>
              </li>
            </ul>
            <div style="clear:both;"></div>
          </div>
        </section>

        <section id="example-negation">
          <h4>Negation Example</h4>
          <p class="issue">
            Negation is a ShEx 2.1 milestone (see the <a href="https://github.com/shexSpec/shex/issues/11">related issue</a>). 
            The spec could include here a form of negation that comes of having a {0,0} cardinality on a triple expression.
          </p>
        </section>

      </section>
  </section>
      
    <section id="shexj">
      <h2>ShEx JSON Syntax (ShExJ)</h2>
      <!-- @@Labra: I think some paragraph is missing here to introduce this section... -->
      <p>
        For instance, "<span class="param">prefixes</span>:{<a class="trmref" href="#dfn-PREFIX">PREFIX</a>-&gt;<a class="trmref" href="#dfn-IRI">IRI</a>}?" indicates that prefixes is optional and if present is a mapping from the terminal <a class="trmref" href="#dfn-PREFIX">PREFIX</a> to the terminal <a class="trmref" href="#dfn-IRI">IRI</a>.
        "<span class="param">base</span>:<a class="trmref" href="#dfn-IRI">IRI</a>?" indicates that <span class="param">base</span> is optional and, if present, is an <a class="trmref" href="#dfn-IRI">IRI</a>.
      </p>
      <div class="shexjTable">
<table class="shexj">
  <tr class="obj"><th id="dfn-Schema" class="obj">Schema</th><td>{</td><td><span class="param">prefixes</span>:{<a class="trmref" href="#dfn-PREFIX">PREFIX</a>-&gt;<a class="trmref" href="#dfn-IRI">IRI</a>}? <span class="param">base</span>:<a class="trmref" href="#dfn-IRI">IRI</a>? <span class="param">startActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">start</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">shapes</span>:{<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>-&gt;<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>}? }</td></tr>
  <tr class="nob"><th id="dfn-shapeLabel" class="nob">shapeLabel</th><td>=</td><td><a class="trmref" href="#dfn-IRI">IRI</a> | <a class="trmref" href="#dfn-BNODE">BNODE</a> ;</td></tr>
  <tr class="nob"><th id="dfn-shapeExpr" class="nob">shapeExpr</th><td>=</td><td><a class="objref" href="#dfn-ShapeOr">ShapeOr</a> | <a class="objref" href="#dfn-ShapeAnd">ShapeAnd</a> | <a class="objref" href="#dfn-ShapeNot">ShapeNot</a> | <a class="objref" href="#dfn-NodeConstraint">NodeConstraint</a> | <a class="objref" href="#dfn-Shape">Shape</a> | <a class="objref" href="#dfn-ShapeRef">ShapeRef</a> | <a class="objref" href="#dfn-ShapeExternal">ShapeExternal</a> ;</td></tr>
  <tr class="obj"><th id="dfn-ShapeOr" class="obj">ShapeOr</th><td>{</td><td><span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
  <tr class="obj"><th id="dfn-ShapeAnd" class="obj">ShapeAnd</th><td>{</td><td><span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
  <tr class="obj"><th id="dfn-ShapeNot" class="obj">ShapeNot</th><td>{</td><td><span class="param">shapeExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a> }</td></tr>
  <tr class="obj"><th id="dfn-Shape" class="obj">Shape</th><td>{</td><td><span class="param">virtual</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">closed</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">extra</span>:[<a class="trmref" href="#dfn-IRI">IRI</a>]? <span class="param">expression</span>:<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>? <span class="param">inherit</span>:[<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>]? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-ShapeRef" class="obj">ShapeRef</th><td>{</td><td><span class="param">reference</span>:<a class="trmref" href="#dfn-shapeLabel">shapeLabel</a> }</td></tr>
  <tr class="obj"><th id="dfn-ShapeExternal" class="obj">ShapeExternal</th><td>{</td><td><span class="comment">/* empty */</span> }</td></tr>
  <tr class="obj"><th id="dfn-SemAct" class="obj">SemAct</th><td>{</td><td><span class="param">name</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">code</span>:<a class="trmref" href="#dfn-STRING">STRING</a>? }</td></tr>
  <tr class="nob"><th id="dfn-tripleExpr" class="nob">tripleExpr</th><td>=</td><td><a class="objref" href="#dfn-EachOf">EachOf</a> | <a class="objref" href="#dfn-OneOf">OneOf</a> | <a class="objref" href="#dfn-TripleConstraint">TripleConstraint</a> | <a class="objref" href="#dfn-Inclusion">Inclusion</a> ;</td></tr>
  <tr class="obj"><th id="dfn-EachOf" class="obj">EachOf</th><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-OneOf" class="obj">OneOf</th><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-Inclusion" class="obj">Inclusion</th><td>{</td><td><span class="param">include</span>:<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a> }</td></tr>
  <tr class="obj"><th id="dfn-TripleConstraint" class="obj">TripleConstraint</th><td>{</td><td><span class="param">inverse</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">valueExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-NodeConstraint" class="obj">NodeConstraint</th><td>{</td><td><span class="param">nodeKind</span>:(<span class="literal">"iri"</span> | <span class="literal">"bnode"</span> | <span class="literal">"nonliteral"</span> | <span class="literal">"literal"</span>)? <span class="param">datatype</span>:<a class="trmref" href="#dfn-IRI">IRI</a>? <a class="nobref" href="#dfn-xsFacet">xsFacet</a>* <span class="param">values</span>:[<a class="nobref" href="#dfn-valueSetValue">valueSetValue</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-Annotation" class="obj">Annotation</th><td>{</td><td><span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">object</span>:<a class="nobref" href="#dfn-objectValue">objectValue</a> }</td></tr>
  <tr class="nob"><th id="dfn-xsFacet" class="nob">xsFacet</th><td>=</td><td><a class="nobref" href="#dfn-stringFacet">stringFacet</a> | <a class="nobref" href="#dfn-numericFacet">numericFacet</a> ;</td></tr>
  <tr class="nob"><th id="dfn-stringFacet" class="nob">stringFacet</th><td>=</td><td>(<span class="param">"length"</span>|<span class="param">"minlength"</span>|<span class="param">"maxlength"</span>):<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="param">pattern</span>:<a class="trmref" href="#dfn-STRING">STRING</a> ;</td></tr>
  <tr class="nob"><th id="dfn-numericFacet" class="nob">numericFacet</th><td>=</td><td>(<span class="param">"mininclusive"</span>|<span class="param">"minexclusive"</span>|<span class="param">"maxinclusive"</span>|<span class="param">"maxexclusive"</span>):<a class="nobref" href="#dfn-numericLiteral">numericLiteral</a> </td></tr>
    <tr><th></th><td>|</td><td>(<span class="param">"totaldigits"</span>|<span class="param">"fractiondigits"</span>):<a class="trmref" href="#dfn-INTEGER">INTEGER</a> ;</td></tr>
  <tr class="nob"><th id="dfn-numericLiteral" class="nob">numericLiteral</th><td>=</td><td><a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <a class="trmref" href="#dfn-DECIMAL">DECIMAL</a> | <a class="trmref" href="#dfn-DOUBLE">DOUBLE</a> ;</td></tr>
  <tr class="nob"><th id="dfn-objectValue" class="nob">objectValue</th><td>=</td><td><a class="trmref" href="#dfn-IRI">IRI</a> | <a class="trmref" href="#dfn-STRING">STRING</a> | <a class="trmref" href="#dfn-DATATYPE_STRING">DATATYPE_STRING</a> | <a class="trmref" href="#dfn-LANG_STRING">LANG_STRING</a> ;</td></tr>
  <tr class="nob"><th id="dfn-valueSetValue" class="nob">valueSetValue</th><td>=</td><td><a class="nobref" href="#dfn-objectValue">objectValue</a> | <a class="objref" href="#dfn-Stem">Stem</a> | <a class="objref" href="#dfn-StemRange">StemRange</a> ;</td></tr>
  <tr class="obj"><th id="dfn-Stem" class="obj">Stem</th><td>{</td><td><span class="param">stem</span>:<a class="trmref" href="#dfn-IRI">IRI</a> }</td></tr>
  <tr class="obj"><th id="dfn-StemRange" class="obj">StemRange</th><td>{</td><td><span class="param">stem</span>:(<a class="trmref" href="#dfn-IRI">IRI</a> | <a class="objref" href="#dfn-Wildcard">Wildcard</a>) <span class="param">exclusions</span>:[<a class="nobref" href="#dfn-valueSetValue">valueSetValue</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-Wildcard" class="obj">Wildcard</th><td>{</td><td><span class="comment">/* empty */</span> }</td></tr>
  <tr style="background-color:white; border-left: thin solid white; border-right: thin solid white; "><th colspan="1" style="text-align: left;">Terminals</th><td></td><td>constrained by the <a href="#terminals">terminal rules in the compact syntax</a></td></tr>
<tr class="trm"><th id="dfn-PREFIX" class="trm">PREFIX</th><td>:</td><td><a class="grammarRef" href="#term-PN_PREFIX">PN_PREFIX</a></td></tr>
  <tr class="trm"><th id="dfn-IRI" class="trm">IRI</th><td>:</td><td>( [^#0000- &lt;&gt;\"{}|^`\\] | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span> )* <span class="comment"># (<a class="grammarRef" href="#term-IRIREF">IRIREF</a> without the enclosing "&lt;&gt;"s)</span></td></tr>
  <tr class="trm"><th id="dfn-BNODE" class="trm">BNODE</th><td>:</td><td><a class="grammarRef" href="#term-BLANK_NODE_LABEL">BLANK_NODE_LABEL</a></td></tr>
  <tr class="trm"><th id="dfn-BOOL" class="trm">BOOL</th><td>:</td><td>"true" | "false" <span class="comment"># a JSON boolean value</span></td></tr>
  <tr class="trm"><th id="dfn-INTEGER" class="trm">INTEGER</th><td>:</td><td><a class="grammarRef" href="#term-INTEGER">INTEGER</a> <span class="comment"># a JSON string matching the lexical form of an integer</span></td></tr>
  <tr class="trm"><th id="dfn-DECIMAL" class="trm">DECIMAL</th><td>:</td><td><a class="grammarRef" href="#term-DECIMAL">DECIMAL</a> <span class="comment"># a JSON string matching the lexical form of an decimal</span></td></tr>
  <tr class="trm"><th id="dfn-DOUBLE" class="trm">DOUBLE</th><td>:</td><td><a class="grammarRef" href="#term-DOUBLE">DOUBLE</a> <span class="comment"># a JSON string matching the lexical form of an double</span></td></tr>
  <tr class="trm"><th id="dfn-STRING" class="trm">STRING</th><td>:</td><td>'"' .* '"' <span class="comment"># a JSON string starting and ending with the U+0022 (") character</span></td></tr>
  <tr class="trm"><th id="dfn-DATATYPE_STRING" class="trm">DATATYPE_STRING</th><td>:</td><td>'"' .* '"' ( [^#0000- &lt;&gt;\"{}|^`\\] | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span> )* <span class="comment"># a JSON string starting with U+0022 ("), followed by the lexical form of the string, then U+0022 U+005E U+005E ("^^) and the <a href="#dfn-IRI">IRI</a> of the datatype</span></td></tr>
  <tr class="trm"><th id="dfn-LANG_STRING" class="trm">LANG_STRING</th><td>:</td><td>'"' .* '"@' <span class="prod"><a class="grammarRef" href="#term-LANGTAG">LANGTAG</a></span> <span class="comment"># a JSON string starting with U+0022 ("), followed by the lexical form of the string, then U+0022 U+0040 ("@) and the <span class="prod"><a class="grammarRef" href="#term-LANGTAG">LANGTAG</a></span></span></td></tr>
</table>
</div>

    </section>

    <section id="shexc">
      <h2>ShEx Compact syntax (ShExC)</h2>
      <!-- @@Labra: It is strange to talk about parsing ShEx compact syntax without saying what it is...I think some paragraph or explanation is needed, 
       or maybe title this section "ShEx Compact syntax" and include the grammar and then, how to parse it --> 

      <div class="example">
          <div class="example-title marker"><span>Parsing ShExC Example 1</span></div>
          <p>An employee must have an email address that is the string "N/A" or starts with "engineering-"  or "sales-" but not "sales-contacts" or "sales-interns":</p>
  <p>
    Following is a ShEx schema written in ShExC with line numbers added at the left for reference.
  </p>


<pre class="shex">

      PREFIX ex:   &lt;http://schema.example/&gt;
      PREFIX foaf: &lt;http://xmlns.com/foaf/&gt;
      PREFIX xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
      PREFIX rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

1     &lt;IssueShape&gt; CLOSED EXTRA rdf:type
2     {                           
3         rdf:type [ex:Issue];
4         ex:state [ex:unassigned ex:assigned]; 
5                                            
6         ex:reportedBy @&lt;UserShape&gt;;   
7         ex:reportedOn xsd:dateTime;         
8         (                                   
9           ex:reproducedBy @&lt;EmployeeShape&gt;;  
10          ex:reproducedOn xsd:dateTime OR xsd:date 
11        )?;
12        ^ex:related @&lt;IssueShape&gt;*            
13    }
14
15    &lt;UserShape&gt; PATTERN "^http:/example.org/.*" {                     
16        (                                   
17           foaf:name xsd:string             
18         |                                  
19           foaf:givenName xsd:string+;      
20           foaf:familyName xsd:string
21        );     
22        foaf:mbox IRI              
23    }
24
25    &lt;EmployeeShape&gt; {        
26        foaf:phone IRI*;          
27        foaf:mbox IRI             
28    } AND {
29        ( foaf:phone PATTERN "^tel:\\+33"; 
30          foaf:mbox PATTERN "\\.fr$" )?;
31        ( foaf:phone PATTERN "^tel:\\+44"; 
32          foaf:mbox PATTERN "\\.uk$")?
33    }
</pre>
  <p>
    We first explain some elements of the concrete syntax. 
    A triple expression is surrounded by curly braces { and }.
    The square braces delimit sets of values.
    Parentheses are used as usual for defining the structre of an expression.
    We use abbreviations for some intervals of min and max cardinality, namely, '+' is the interval [1;*], '*' is the interval [0;*], and '?' is the interval [0;1].
  </p>

  <p>
    Then, the schema here above defines three shape labels: <span class="pre">&lt;IssueShape&gt;, &lt;UserShape&gt;, &lt;EmployeeShape&gt;</span>.
  </p>
  <p>
    The shape expression that defines the shape label <span class="pre">&lt;IssueShape&gt;</span> starts on line 1 after the shape label, and ends with the curly bracket on line 13.
    It has an empty list of node constraints, and a single shape definition.
    The shape definition has two modifiers, <m>CLOSED</m>, and <m>EXTRA</m>. 
    The parameter of the <m>EXTRA</m> modifier is a singleton set that contains the property <span class="pre">rdf:type</span>.
  </p>
  <p>
    The triple expression in the shape definition is given between the curly braces on lines 2 and 13.
    It is an each-of expression composed of six sub-expressions, separated by semicolons. 
    The sub-expressions are as follows:
  </p>
    <ul>
      <li>
        Four triple constraints on lines 3, 4, 6, 7.
      </li>
      <li>
        Two repeated triple expressions, one on lines 8--11 with cardinality ? = [0;1], another one on line 12 with cardinality * = [0;*].
      </li>
    </ul>

  <p>
    We explain the different forms of triple constraint that appear in the definition of <span class="pre">&lt;IssueShape&gt;</span>, by explaining their property or their value expression.
  </p>

<pre>
1     &lt;IssueShape&gt; CLOSED EXTRA rdf:type
2     {                           
3         a [ex:Issue];                              <span class="comment"># rdf:type of ex:Issue</span>
4         ex:state [ex:unassigned ex:assigned];      <span class="comment"># ex:state of ex:unassigned</span>
                                                     <span class="comment">#          or ex:assigned</span>
5
6         ex:reportedBy @&lt;UserShape&gt;;                <span class="comment"># <span class="jobjref"><a href="#dfn-ShapeRef" class="obj">ShapeRef</a></span> to &lt;UserShape&gt;</span>

7         ex:reportedOn xsd:dateTime;                <span class="comment"># literal with datatype xsd:dateTime</span>
8         (
9           ex:reproducedBy @&lt;EmployeeShape&gt;;        <span class="comment"># <span class="jobjref"><a href="#dfn-ShapeRef" class="obj">ShapeRef</a></span> to &lt;EmployeeShape&gt;</span>
10          ex:reproducedOn xsd:dateTime OR xsd:date # literal with datatype xsd:dateTime
                                                     <span class="comment">#                    or xsd:date</span>
11        )?;
12        ex:related @&lt;IssueShape&gt;*            
13    }
</pre>

  <p>
    We now explain a few other elements of the syntax.
  </p>

<pre>
15    &lt;UserShape&gt; PATTERN "^http:/example.org/.*" {                     
         ‚Ä¶
23    }
</pre>  

  <p>
    The shape expression that defines <span class="pre">&lt;UserShape&gt;</span> is composed of one node constraint <span class="pre">PATTERN "^http:/example.org/.*"</span> and one shape definition between the curly braces lines 15 to 23.
    The node constraint <span class="pre">PATTERN "^http:/example.org/.*"</span> defines the set of IRI that satisfy a pattern given by a regular expression.
  </p>

<pre>
25    &lt;EmployeeShape&gt; {        
        ‚Ä¶
28    } AND {
        ‚Ä¶
33    }
</pre>

  <p>
    The shape expression that defines <span class="pre">&lt;EmployeeShape&gt;</span> is composed of zero node constrainst, and two shape definitions, separated by an <span class="pre">AND</span>.
  </p>
      </div>

      <div class="grammarTable">
<table border="0">

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      A ShEx document produces a schema.
      Semantic actions before the first <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shape expression declaration</a></span> are <span class="param"><a href="#dfn-Schema">startActs</a></span>.
      After the first <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shape expression declaration</a></span>, semantic actions are associated with the previous declaration.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-shexDoc">[<span class="prodNo">1</span>]¬†¬†¬†</td>
<td><code class="production prod">shexDoc</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-directive">directive</a></span>* ((<span class="prod"><a class="grammarRef" href="#prod-notStartAction">notStartAction</a></span> | <span class="prod"><a class="grammarRef" href="#prod-startActions">startActions</a></span>) <span class="prod"><a class="grammarRef" href="#prod-statement">statement</a></span>*)?</code></td>
</tr>
<tr class="obj"><td></td><td><a href="#dfn-Schema" class="obj">Schema</a></td><td>{</td><td>
<span class="param">startActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]?
<span class="param">start</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>?
<span class="param">shapes</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>+]? }
</td></tr>
  <tr class="params"><td></td><td colspan="3"><ul>
<li><span class="param">startActs</span> comes from <span class="prod"><a class="grammarRef" href="#prod-startActions">startActions</a></span> production.</li>
<li><span class="param">start</span> comes from the <span class="prod"><a class="grammarRef" href="#prod-start">start</a></span> production.</li>
<li><span class="param">shapes</span> come from the <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shapeExprDecl</a></span> production.</li>
  </ul></td></tr>
<tr valign="baseline">
<td id="prod-directive">[<span class="prodNo">2</span>]¬†¬†¬†</td>
<td><code class="production prod">directive</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-baseDecl">baseDecl</a></span> | <span class="prod"><a class="grammarRef" href="#prod-prefixDecl">prefixDecl</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-baseDecl">[<span class="prodNo">3</span>]¬†¬†¬†</td>
<td><code class="production prod">baseDecl</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"BASE" <span class="prod"><a class="grammarRef" href="#term-IRIREF">IRIREF</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-prefixDecl">[<span class="prodNo">4</span>]¬†¬†¬†</td>
<td><code class="production prod">prefixDecl</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"PREFIX" <span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span> <span class="prod"><a class="grammarRef" href="#term-IRIREF">IRIREF</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-notStartAction">[<span class="prodNo">5</span>]¬†¬†¬†</td>
<td><code class="production prod">notStartAction</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-start">start</a></span> | <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shapeExprDecl</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-start">[<span class="prodNo">6</span>]¬†¬†¬†</td>
<td><code class="production prod">start</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"start" "=" <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-startActions">[<span class="prodNo">7</span>]¬†¬†¬†</td>
<td><code class="production prod">startActions</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-codeDecl">codeDecl</a></span>+</code></td>
</tr>
<tr valign="baseline">
<td id="prod-statement">[<span class="prodNo">8</span>]¬†¬†¬†</td>
<td><code class="production prod">statement</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-directive">directive</a></span> | <span class="prod"><a class="grammarRef" href="#prod-notStartAction">notStartAction</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-shapeExprDecl">[<span class="prodNo">9</span>]¬†¬†¬†</td>
<td><code class="production prod">shapeExprDecl</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-shapeLabel">shapeLabel</a></span> (<span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span> | "EXTERNAL")</code></td>
</tr>
  <tr class="params"><td></td><td colspan="3">If the "<code>EXTERNAL</code>" keyword is present, <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shapeExprDecl</a></span> returns a <a href="#dfn-ShapeExternal" class="obj">ShapeExternal</a> object:</td></tr>
  <tr class="obj"><td></td><td><a href="#dfn-ShapeExternal" class="obj">ShapeExternal</a></td><td>{</td><td><span class="comment">/* empty */</span> }</td></tr>
  <tr class="params"><td></td><td colspan="3">otherwise <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shapeExprDecl</a></span> returns <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span>.</td></tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      Shape expressions are logical combinations of shape atoms.
      Inline variants of shape expressions are used in <span class="prod"><a class="grammarRef" href="#prod-tripleConstraint">tripleConstraint</a></span>s and are not permitted to have annotations or semantic actions.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-shapeExpression">[<span class="prodNo">10</span>]¬†¬†¬†</td>
<td><code class="production prod">shapeExpression</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-shapeOr">shapeOr</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-inlineShapeExpression">[<span class="prodNo">14</span>]¬†¬†¬†</td>
<td><code class="production prod">inlineShapeExpression</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-inlineShapeOr">inlineShapeOr</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-shapeOr">[<span class="prodNo">11</span>]¬†¬†¬†</td>
<td><code class="production prod">shapeOr</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a></span> ("OR" <span class="prod"><a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a></span>)*</code></td>
</tr>
<tr valign="baseline">
<td id="prod-inlineShapeOr">[<span class="prodNo">15</span>]¬†¬†¬†</td>
<td><code class="production prod">inlineShapeOr</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-inlineShapeAnd">inlineShapeAnd</a></span> ("OR" <span class="prod"><a class="grammarRef" href="#prod-inlineShapeAnd">inlineShapeAnd</a></span>)*</code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
If the right <a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a> matches one or more times, the result is a <a href="#dfn-ShapeOr" class="obj">ShapeOr</a> object with <span class="param">shapeExprs</span> containing the first <a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a> followed by the ordered list from the second <a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a>:
</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-ShapeOr" class="obj">ShapeOr</a></td><td>{</td><td><span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
<tr class="params"><td></td><td colspan="3">
otherwise the result is the left <a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a>.
</td></tr>
<tr valign="baseline">
<td id="prod-shapeAnd">[<span class="prodNo">12</span>]¬†¬†¬†</td>
<td><code class="production prod">shapeAnd</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-shapeNot">shapeNot</a></span> ("AND" <span class="prod"><a class="grammarRef" href="#prod-shapeNot">shapeNot</a></span>)*</code></td>
</tr>
<tr valign="baseline">
<td id="prod-inlineShapeAnd">[<span class="prodNo">16</span>]¬†¬†¬†</td>
<td><code class="production prod">inlineShapeAnd</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-inlineShapeNot">inlineShapeNot</a></span> ("AND" <span class="prod"><a class="grammarRef" href="#prod-inlineShapeNot">inlineShapeNot</a></span>)*</code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
If the right <a class="grammarRef" href="#prod-shapeNot">shapeNot</a> matches one or more times, the result is a <a href="#dfn-ShapeAnd" class="obj">ShapeAnd</a> object with <span class="param">shapeExprs</span> containing the first <a class="grammarRef" href="#prod-shapeNot">shapeNot</a> followed by the ordered list from the second <a class="grammarRef" href="#prod-shapeNot">shapeNot</a>:
</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-ShapeAnd" class="obj">ShapeAnd</a></td><td>{</td><td><span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
<tr class="params"><td></td><td colspan="3">
otherwise the result is the left <a class="grammarRef" href="#prod-shapeNot">shapeNot</a>.
</td></tr>
<tr valign="baseline">
<td id="prod-shapeNot">[<span class="prodNo">13</span>]¬†¬†¬†</td>
<td><code class="production prod">shapeNot</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"NOT"? <span class="prod"><a class="grammarRef" href="#prod-shapeAtom">shapeAtom</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-inlineShapeNot">[<span class="prodNo">17</span>]¬†¬†¬†</td>
<td><code class="production prod">inlineShapeNot</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"NOT"? <span class="prod"><a class="grammarRef" href="#prod-inlineShapeAtom">inlineShapeAtom</a></span></code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
If the left "<code>NOT</code>" matches, the result is a <a href="#dfn-ShapeNot" class="obj">ShapeNot</a> object with <span class="param">shapeExpr</span> containing the <a class="grammarRef" href="#prod-shapeAtom">shapeAtom</a>:</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-ShapeNot" class="obj">ShapeNot</a></td><td>{</td><td><span class="param">shapeExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a> }</td></tr>
<tr class="params"><td></td><td colspan="3">
otherwise the result is the <a class="grammarRef" href="#prod-shapeAtom">shapeAtom</a>.
</td></tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      Shape atoms are shape references (indicated by "<code>@</code>"), definitions, or nested expressions.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-shapeAtom">[<span class="prodNo">29</span>]¬†¬†¬†</td>
<td><code class="production prod">shapeAtom</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content"><span class="prod"><a class="grammarRef" href="#prod-nodeConstraint">nodeConstraint</a></span> <span class="prod"><a class="grammarRef" href="#prod-shapeOrRef">shapeOrRef</a></span>?<br/>
| <span class="prod"><a class="grammarRef" href="#prod-shapeOrRef">shapeOrRef</a></span><br/>
| "(" <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span> ")"<br/>
| "."</code></td>
</tr>
<tr valign="baseline">
<td id="prod-inlineShapeAtom">[<span class="prodNo">30</span>]¬†¬†¬†</td>
<td><code class="production prod">inlineShapeAtom</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content"><span class="prod"><a class="grammarRef" href="#prod-nodeConstraint">nodeConstraint</a></span> <span class="prod"><a class="grammarRef" href="#prod-inlineShapeOrRef">inlineShapeOrRef</a></span>?<br/>
| <span class="prod"><a class="grammarRef" href="#prod-inlineShapeOrRef">inlineShapeOrRef</a></span> <span class="prod"><a class="grammarRef" href="#prod-nodeConstraint">nodeConstraint</a></span>?<br/>
| "(" <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span> ")"<br/>
| "."</code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
<ul>
  <li>If the matching production inludes both a  <span class="prod"><a class="grammarRef" href="#prod-nodeConstraint">nodeConstraint</a></span> and a <span class="prod"><a class="grammarRef" href="#prod-shapeOrRef">shapeOrRef</a></span>, the result is a <a href="#dfn-ShapeAnd" class="obj">ShapeAnd</a> object with <span class="param">shapeExprs</span> containing the list of <span class="prod"><a class="grammarRef" href="#prod-nodeConstraint">nodeConstraint</a></span> and a <span class="prod"><a class="grammarRef" href="#prod-shapeOrRef">shapeOrRef</a></span>.</li>
  <li>If the "(" <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span> ")" production matches, the result is the result of <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span>.</li>
  <li>If the <code>"."</code> production matches, the result is an empty shape: <code>{"type": "Shape"}</code>.</li>
</ul>
</td></tr>
<tr valign="baseline">
<td id="prod-shapeOrRef">[<span class="prodNo">46</span>]¬†¬†¬†</td>
<td><code class="production prod">shapeOrRef</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content">
<span class="prod"><a class="grammarRef" href="#prod-shapeDefinition">shapeDefinition</a></span><br/>
| <span class="prod"><a class="grammarRef" href="#term-ATPNAME_LN">ATPNAME_LN</a></span> | <span class="prod"><a class="grammarRef" href="#term-ATPNAME_NS">ATPNAME_NS</a></span> | "@" <span class="prod"><a class="grammarRef" href="#prod-shapeLabel">shapeLabel</a></span><br/>
</code></td>
</tr>
<tr valign="baseline">
<td id="prod-inlineShapeOrRef">[<span class="prodNo">47</span>]¬†¬†¬†</td>
<td><code class="production prod">inlineShapeOrRef</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content"><span class="prod"><a class="grammarRef" href="#prod-inlineShapeDefinition">inlineShapeDefinition</a></span><br/>
| <span class="prod"><a class="grammarRef" href="#term-ATPNAME_LN">ATPNAME_LN</a></span> | <span class="prod"><a class="grammarRef" href="#term-ATPNAME_NS">ATPNAME_NS</a></span> | "@" <span class="prod"><a class="grammarRef" href="#prod-shapeLabel">shapeLabel</a></span><br/></code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
<ul>
  <li>If the <span class="prod"><a class="grammarRef" href="#prod-shapeDefinition">shapeDefinition</a></span> production matches, the result is <span class="prod"><a class="grammarRef" href="#prod-shapeDefinition">shapeDefinition</a></span>.</li>
  <li>Otherwise, the result is a <a href="#dfn-ShapeRef" class="obj">ShapeRef</a> object with <span class="param">reference</span> being the matching characters after the initial "<code>@</code>".</li>
</ul>
</td></tr>
  <tr class="obj"><td></td><td id="dfn-ShapeRef" class="obj">ShapeRef</td><td>{</td><td><span class="param">reference</span>:<a class="trmref" href="#dfn-IRI">IRI</a> }</td></tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td colspan="4">
    <p>
      Node constraints identify a (possibly infinite) set of matching RDF nodes.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-nodeConstraint">[<span class="prodNo">31</span>]¬†¬†¬†</td>
<td><code class="production prod">nodeConstraint</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content">"LITERAL" <span class="prod"><a class="grammarRef" href="#prod-xsFacet">xsFacet</a></span>*<br/>
| <span class="prod"><a class="grammarRef" href="#prod-nonLiteralKind">nonLiteralKind</a></span> <span class="prod"><a class="grammarRef" href="#prod-stringFacet">stringFacet</a></span>*<br/>
| <span class="prod"><a class="grammarRef" href="#prod-datatype">datatype</a></span> <span class="prod"><a class="grammarRef" href="#prod-xsFacet">xsFacet</a></span>*<br/>
| <span class="prod"><a class="grammarRef" href="#prod-valueSet">valueSet</a></span> <span class="prod"><a class="grammarRef" href="#prod-xsFacet">xsFacet</a></span>*<br/>
| <span class="prod"><a class="grammarRef" href="#prod-xsFacet">xsFacet</a></span>+</code></td>
</tr>
<tr class="obj"><td></td><td><a href="#dfn-NodeConstraint" class="obj">NodeConstraint</a></td><td>{</td><td><span class="param">nodeKind</span>:(<span class="literal">"iri"</span> | <span class="literal">"bnode"</span> | <span class="literal">"nonliteral"</span> | <span class="literal">"literal"</span>)? <span class="param">datatype</span>:<a class="trmref" href="#dfn-IRI">IRI</a>? <a class="nobref" href="#dfn-xsFacet">xsFacet</a>* <span class="param">values</span>:[<a class="nobref" href="#dfn-valueSetValue">valueSetValue</a>]? }</td></tr>
<tr valign="baseline">
<td id="prod-nonLiteralKind">[<span class="prodNo">32</span>]¬†¬†¬†</td>
<td><code class="production prod">nonLiteralKind</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"IRI" | "BNODE" | "NONLITERAL"</code></td>
</tr>
<tr valign="baseline">
<td id="prod-xsFacet">[<span class="prodNo">33</span>]¬†¬†¬†</td>
<td><code class="production prod">xsFacet</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-stringFacet">stringFacet</a></span> | <span class="prod"><a class="grammarRef" href="#prod-numericFacet">numericFacet</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-stringFacet">[<span class="prodNo">34</span>]¬†¬†¬†</td>
<td><code class="production prod">stringFacet</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content"><span class="prod"><a class="grammarRef" href="#prod-stringLength">stringLength</a></span> <span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span><br/>
| "PATTERN" <span class="prod"><a class="grammarRef" href="#prod-string">string</a></span><br/>
| "~" <span class="prod"><a class="grammarRef" href="#prod-string">string</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-stringLength">[<span class="prodNo">35</span>]¬†¬†¬†</td>
<td><code class="production prod">stringLength</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"LENGTH" | "MINLENGTH" | "MAXLENGTH"</code></td>
</tr>
<tr valign="baseline">
<td id="prod-numericFacet">[<span class="prodNo">36</span>]¬†¬†¬†</td>
<td><code class="production prod">numericFacet</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content"><span class="prod"><a class="grammarRef" href="#prod-numericRange">numericRange</a></span> (<span class="prod"><a class="grammarRef" href="#prod-numericLiteral">numericLiteral</a></span> | <span class="prod"><a class="grammarRef" href="#prod-string">string</a></span> "^^" <span class="prod"><a class="grammarRef" href="#prod-datatype">datatype</a></span>)<br/>
| <span class="prod"><a class="grammarRef" href="#prod-numericLength">numericLength</a></span> <span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-numericRange">[<span class="prodNo">37</span>]¬†¬†¬†</td>
<td><code class="production prod">numericRange</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE"</code></td>
</tr>
<tr valign="baseline">
<td id="prod-numericLength">[<span class="prodNo">38</span>]¬†¬†¬†</td>
<td><code class="production prod">numericLength</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"TOTALDIGITS" | "FRACTIONDIGITS"</code></td>
</tr>
</tbody>

<tbody class="grammarParagraph" style="border-left:thin solid white; border-right:thin solid white;">
  <tr><td colspan="4">
    <p>
      Shape defintions associate a triple expression with a closed flag and a list of partially constrained (extra) predicates.
      Any predicate appearing in a triple expression is fully constrained unless it appears in the list of extras.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-shapeDefinition">[<span class="prodNo">18</span>]¬†¬†¬†</td>
<td><code class="production prod">shapeDefinition</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">(<!-- <span class="prod"><a class="grammarRef" href="#prod-includeSet">includeSet</a></span> | --><span class="prod"><a class="grammarRef" href="#prod-extraPropertySet">extraPropertySet</a></span> | "CLOSED")* "{" <span class="prod"><a class="grammarRef" href="#prod-tripleExpression">tripleExpression</a></span>? "}" <span class="prod"><a class="grammarRef" href="#prod-annotation">annotation</a></span>* <span class="prod"><a class="grammarRef" href="#prod-semanticActions">semanticActions</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-inlineShapeDefinition">[<span class="prodNo">19</span>]¬†¬†¬†</td>
<td><code class="production prod">inlineShapeDefinition</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">(<!-- <span class="prod"><a class="grammarRef" href="#prod-includeSet">includeSet</a></span> | --><span class="prod"><a class="grammarRef" href="#prod-extraPropertySet">extraPropertySet</a></span> | "CLOSED")* "{" <span class="prod"><a class="grammarRef" href="#prod-tripleExpression">tripleExpression</a></span>? "}"</code></td>
</tr>
<tr class="obj"><td></td><td><a href="#dfn-Shape" class="obj">Shape</a></td><td>{</td><td>
<!-- <span class="param">virtual</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? -->
<span class="param">closed</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>?
<span class="param">extra</span>:[<a class="trmref" href="#dfn-IRI">IRI</a>]?
<span class="param">expression</span>:<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>?
<!-- <span class="param">inherit</span>:[<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>]? -->
<span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]?
<span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? }</td></tr>
  <tr class="params"><td></td><td colspan="3"><ul>
  <li><span class="param">closed</span> is true if the "<code>CLOSED</code>" choice was matched one or more times.</li>
  <li><span class="param">extra</span> is the set of IRIs matching the <a class="grammarRef" href="#prod-extraPropertySet">extraPropertySet</a> production.</li>
  <li><span class="param">expression</span> comes from the <a class="grammarRef" href="#prod-tripleExpression">tripleExpression</a> production.</li>
  <li><span class="param">annotations</span> is the set of <a class="objref" href="#dfn-Annotation">Annotation</a>s matching the <span class="prod"><a class="grammarRef" href="#prod-annotation">annotation</a></span> production.</li>
  <li><span class="param">semActs</span> is the set of semantic actions matching the <span class="prod"><a class="grammarRef" href="#prod-semanticActions">semanticActions</a></span> production.</li>
</ul>
  </td></tr>
<tr valign="baseline">
<td id="prod-extraPropertySet">[<span class="prodNo">20</span>]¬†¬†¬†</td>
<td><code class="production prod">extraPropertySet</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"EXTRA" <span class="prod"><a class="grammarRef" href="#prod-predicate">predicate</a></span>+</code></td>
</tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td colspan="4">
    <p>
      Triple expressions are arrangements of triple constraints.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-tripleExpression">[<span class="prodNo">21</span>]¬†¬†¬†</td>
<td><code class="production prod">tripleExpression</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-oneOfTripleExpr">oneOfTripleExpr</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-oneOfTripleExpr">[<span class="prodNo">21</span>]¬†¬†¬†</td>
<td><code class="production prod">oneOfTripleExpr</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a></span> | <span class="prod"><a class="grammarRef" href="#prod-multiElementOneOf">multiElementOneOf</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-multiElementOneOf">[<span class="prodNo">22</span>]¬†¬†¬†</td>
<td><code class="production prod">multiElementOneOf</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a></span> ("|" <span class="prod"><a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a></span>)+</code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
If the right <a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a> matches one or more times, the result is a <a href="#dfn-OneOf" class="obj">OneOf</a> object with <span class="param">expressions</span> containing the first <a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a> followed by the ordered list from the second <a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a>:
</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-OneOf" class="obj">OneOf</a></td><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] }</td></tr>
<tr class="params"><td></td><td colspan="3">
otherwise the result is the left <a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a>.
</td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-innerTripleExpr">[<span class="prodNo">23</span>]¬†¬†¬†</td>
<td><code class="production prod">innerTripleExpr</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-multiElementGroup">multiElementGroup</a></span> | <span class="prod"><a class="grammarRef" href="#prod-multiElementOneOf">multiElementOneOf</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-groupTripleExpr">[<span class="prodNo">24</span>]¬†¬†¬†</td>
<td><code class="production prod">groupTripleExpr</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-singleElementGroup">singleElementGroup</a></span> | <span class="prod"><a class="grammarRef" href="#prod-multiElementGroup">multiElementGroup</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-singleElementGroup">[<span class="prodNo">25</span>]¬†¬†¬†</td>
<td><code class="production prod">singleElementGroup</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a></span> ";"?</code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-multiElementGroup">[<span class="prodNo">26</span>]¬†¬†¬†</td>
<td><code class="production prod">multiElementGroup</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a></span> (";" <span class="prod"><a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a></span>)+ ";"?</code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
If the right <a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a> matches one or more times, the result is a <a href="#dfn-EachOf" class="obj">EachOf</a> object with <span class="param">expressions</span> containing the first <a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a> followed by the ordered list from the second <a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a>:
</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-EachOf" class="obj">EachOf</a></td><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] }</td></tr>
<tr class="params"><td></td><td colspan="3">
otherwise the result is the left <a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a>.
</td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-unaryTripleExpr">[<span class="prodNo">27</span>]¬†¬†¬†</td>
<td><code class="production prod">unaryTripleExpr</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content"><span class="prod"><a class="grammarRef" href="#prod-productionLabel">productionLabel</a></span>? (<span class="prod"><a class="grammarRef" href="#prod-tripleConstraint">tripleConstraint</a></span> | <span class="prod"><a class="grammarRef" href="#prod-bracketedTripleExpr">bracketedTripleExpr</a></span>)<br/>
| <span class="prod"><a class="grammarRef" href="#prod-include">include</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-bracketedTripleExpr">[<span class="prodNo">28</span>]¬†¬†¬†</td>
<td><code class="production prod">bracketedTripleExpr</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"(" <span class="prod"><a class="grammarRef" href="#prod-innerTripleExpr">innerTripleExpr</a></span> ")" <span class="prod"><a class="grammarRef" href="#prod-cardinality">cardinality</a></span>? <span class="prod"><a class="grammarRef" href="#prod-annotation">annotation</a></span>* <span class="prod"><a class="grammarRef" href="#prod-semanticActions">semanticActions</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-productionLabel">[<span class="prodNo">63</span>]¬†¬†¬†</td>
<td><code class="production prod">productionLabel</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"$" (<span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> | <span class="prod"><a class="grammarRef" href="#prod-blankNode">blankNode</a></span>)</code></td>
</tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td colspan="4">
    <p>
      Triple constraints are matched against RDF triples.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-tripleConstraint">[<span class="prodNo">39</span>]¬†¬†¬†</td>
<td><code class="production prod">tripleConstraint</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-senseFlags">senseFlags</a></span>? <span class="prod"><a class="grammarRef" href="#prod-predicate">predicate</a></span> <span class="prod"><a class="grammarRef" href="#prod-inlineShapeExpression">inlineShapeExpression</a></span> <span class="prod"><a class="grammarRef" href="#prod-cardinality">cardinality</a></span>? <span class="prod"><a class="grammarRef" href="#prod-annotation">annotation</a></span>* <span class="prod"><a class="grammarRef" href="#prod-semanticActions">semanticActions</a></span></code></td>
</tr>
<tr class="obj"><td></td><td><a href="#dfn-TripleConstraint" class="obj">TripleConstraint</a></td><td>{</td><td><span class="param">inverse</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">valueExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>

  <tr class="params"><td></td><td colspan="3"><ul>
  <li><span class="param">inverse</span> is true if the <span class="prod"><a class="grammarRef" href="#prod-senseFlags">senseFlags</a></span> matched "<code>^</code>".</li>
  <li><span class="param">predicate</span> comes from the <a class="grammarRef" href="#prod-predicate">predicate</a> production.</li>
  <li><span class="param">valueExpr</span> comes from the <a class="grammarRef" href="#prod-inlineShapeExpression">inlineShapeExpression</a> production. It it is an empty shape <code>{"type": "Shape"}</code>, <span class="param">valueExpr</span> is not assigned.</li>
  <li><span class="param">min</span> comes from the <a class="grammarRef" href="#prod-cardinality">cardinality</a> production.</li>
  <li><span class="param">max</span> comes from the <a class="grammarRef" href="#prod-cardinality">cardinality</a> production.</li>
  <li><span class="param">annotations</span> is the set of <a class="objref" href="#dfn-Annotation">Annotation</a>s matching the <span class="prod"><a class="grammarRef" href="#prod-annotation">annotation</a></span> production.</li>
  <li><span class="param">semActs</span> is the set of semantic actions matching the <span class="prod"><a class="grammarRef" href="#prod-semanticActions">semanticActions</a></span> production.</li>

</ul>
  </td></tr>
<tr valign="baseline">
<td id="prod-cardinality">[<span class="prodNo">53</span>]¬†¬†¬†</td>
<td><code class="production prod">cardinality</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"*" | "+" | "?" | <span class="prod"><a class="grammarRef" href="#term-REPEAT_RANGE">REPEAT_RANGE</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-senseFlags">[<span class="prodNo">40</span>]¬†¬†¬†</td>
<td><code class="production prod">senseFlags</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"^"</code></td>
</tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td colspan="4">
    <p>
      Value sets identify ranges of RDF nodes by explicit inclusion or by range (indicated by "<code>~</code>").
      Ranges may include exclusions, which may also be ranges but must not in turn contain exclusions.
      A <a href="#dfn-valueSetValue" class="param">valueSetValue</a> may be an <a class="param" href="#dfn-objectValue">objectValue</a> or a <a class="param" href="#dfn-Stem">Stem</a> or a <a class="param" href="#dfn-StemRange">StemRange</a>.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-valueSet">[<span class="prodNo">41</span>]¬†¬†¬†</td>
<td><code class="production prod">valueSet</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"[" <span class="prod"><a class="grammarRef" href="#prod-valueSetValue">valueSetValue</a></span>* "]"</code></td>
</tr>
<tr valign="baseline">
<td id="prod-valueSetValue">[<span class="prodNo">42</span>]¬†¬†¬†</td>
<td><code class="production prod">valueSetValue</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-iriRange">iriRange</a></span> | <span class="prod"><a class="grammarRef" href="#prod-literal">literal</a></span></code></td>
</tr>
<tr valign="baseline">
<td id="prod-iriRange">[<span class="prodNo">43</span>]¬†¬†¬†</td>
<td><code class="production prod">iriRange</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content"><span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> ("~" <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>*)?<br/>
| "." <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>+</code></td>
</tr>
  <tr class="params"><td></td><td colspan="3">If <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> matches with no "<code>~</code>", iriRange returns <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span>.</td></tr>
  <tr class="params"><td></td><td colspan="3">If <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> and "<code>~</code>" match with no <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>, iriRange returns a <a href="#dfn-Stem" class="obj">Stem</a> object:</td></tr>
  <tr class="obj"><td></td><td><a href="#dfn-Stem" class="obj">Stem</a></td><td>{</td><td><span class="param">stem</span>:<a class="trmref" href="#dfn-IRI">IRI</a> }</td></tr>
  <tr class="params"><td></td><td colspan="3">If <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> and "<code>~</code>" match and <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span> matches one or more times, iriRange returns a <a href="#dfn-StemRange" class="obj">StemRange</a> object with <span class="param">exclusions</span> equal to the set of results of <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>:</td></tr>
  <tr class="params"><td></td><td colspan="3">If "<code>.</code>" matches and <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span> matches one or more times, iriRange returns a <a href="#dfn-StemRange" class="obj">StemRange</a> object with <span class="param">exclusions</span> equal to the set of results of <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>:</td></tr>
  <tr class="obj"><td></td><td><a href="#dfn-StemRange" class="obj">StemRange</a></td><td>{</td><td><span class="param">stem</span>:(<a class="trmref" href="#dfn-IRI">IRI</a> | <a class="objref" href="#dfn-Wildcard">Wildcard</a>) <span class="param">exclusions</span>:[<a class="nobref" href="#dfn-valueSetValue">valueSetValue</a>]? }</td></tr>
  <tr class="params"><td></td><td colspan="3">If "<code>~</code>" matches with no <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>, iriRange returns a <a href="#dfn-Wildcard" class="obj">Wildcard</a> object:</td></tr>
  <tr class="obj"><td></td><td><a href="#dfn-Wildcard" class="obj">Wildcard</a></td><td>{</td><td><span class="comment">/* contains no properties */</span> }</td></tr>
<tr valign="baseline">
<td id="prod-exclusion">[<span class="prodNo">44</span>]¬†¬†¬†</td>
<td><code class="production prod">exclusion</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"-" <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> "~"?</code></td>
</tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td colspan="4">
    <p>
      Triple expressions can include the <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span> in a <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shapeExprDecl</a></span>.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-include">[<span class="prodNo">48</span>]¬†¬†¬†</td>
<td><code class="production prod">include</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"&amp;" <span class="prod"><a class="grammarRef" href="#prod-shapeLabel">shapeLabel</a></span></code></td>
</tr>
  <tr class="params"><td></td><td colspan="3">Per the <a href="#inclusion-constraint">inclusion constraint</a>, <span class="param">shapeLabel</span> property MUST appear in the schema's <span class="param">shapes</span> map and the corresponding triple expression MUST be a <span class="jobjref"><a href="#dfn-Shape">Shape</a></span> with a <span class="param">tripleExpr</span>.</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-Inclusion" class="obj">Inclusion</a></td><td>{</td><td><span class="param">include</span>:<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a> }</td></tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td colspan="4">
    <p>
      Triple expressions can include annotations in the form of a tuple of a <span class="prod"><a class="grammarRef" href="#prod-predicate">predicate</a></span> and an <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> or <span class="prod"><a class="grammarRef" href="#prod-literal">literal</a></span>.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-annotation">[<span class="prodNo">50</span>]¬†¬†¬†</td>
<td><code class="production prod">annotation</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"//" <span class="prod"><a class="grammarRef" href="#prod-predicate">predicate</a></span> (<span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> | <span class="prod"><a class="grammarRef" href="#prod-literal">literal</a></span>)</code></td>
</tr>
  <tr class="obj"><td></td><td><a href="#dfn-Annotation" class="obj">Annotation</a></td><td>{</td><td><span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">object</span>:<a class="nobref" href="#dfn-objectValue">objectValue</a> }</td></tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td colspan="4">
    <p>
      Triple expressions can include semantic actions consisting of an <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> and an optional code string.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-semanticActions">[<span class="prodNo">49</span>]¬†¬†¬†</td>
<td><code class="production prod">semanticActions</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-codeDecl">codeDecl</a></span>*</code></td>
</tr>
<tr valign="baseline">
<td id="prod-codeDecl">[<span class="prodNo">62</span>]¬†¬†¬†</td>
<td><code class="production prod">codeDecl</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"%" <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> (<span class="prod"><a class="grammarRef" href="#term-CODE">CODE</a></span> | "%")</code></td>
</tr>
  <tr class="obj"><td></td><td><a href="#dfn-SemAct" class="obj">SemAct</a></td><td>{</td><td><span class="param">name</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">code</span>:<a class="trmref" href="#dfn-STRING">STRING</a>? }</td></tr>
</tbody>

<!-- 
<tbody class="prod">
<tr valign="baseline">
<td id="prod-includeSet">[<span class="prodNo">64</span>]¬†¬†¬†</td>
<td><code class="production prod">includeSet</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"&amp;" <span class="prod"><a class="grammarRef" href="#prod-shapeLabel">shapeLabel</a></span>+</code></td>
</tr>
</tbody>
-->

<tbody class="grammarParagraph">
  <tr><td colspan="4">
    <p>
      The remaining productions come from the specifications for SPARQL and Turtle.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-literal">[<span class="prodNo">45</span>]¬†¬†¬†</td>
<td><code class="production prod">literal</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-rdfLiteral">rdfLiteral</a></span> | <span class="prod"><a class="grammarRef" href="#prod-numericLiteral">numericLiteral</a></span> | <span class="prod"><a class="grammarRef" href="#prod-booleanLiteral">booleanLiteral</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-predicate">[<span class="prodNo">51</span>]¬†¬†¬†</td>
<td><code class="production prod">predicate</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> | <span class="prod"><a class="grammarRef" href="#term-RDF_TYPE">RDF_TYPE</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-datatype">[<span class="prodNo">52</span>]¬†¬†¬†</td>
<td><code class="production prod">datatype</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-shapeLabel">[<span class="prodNo">54</span>]¬†¬†¬†</td>
<td><code class="production prod">shapeLabel</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> | <span class="prod"><a class="grammarRef" href="#prod-blankNode">blankNode</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-numericLiteral">[<span class="prodNo">55</span>]¬†¬†¬†</td>
<td><code class="production prod">numericLiteral</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span> | <span class="prod"><a class="grammarRef" href="#term-DECIMAL">DECIMAL</a></span> | <span class="prod"><a class="grammarRef" href="#term-DOUBLE">DOUBLE</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-rdfLiteral">[<span class="prodNo">56</span>]¬†¬†¬†</td>
<td><code class="production prod">rdfLiteral</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-string">string</a></span> (<span class="prod"><a class="grammarRef" href="#term-LANGTAG">LANGTAG</a></span> | "^^" <span class="prod"><a class="grammarRef" href="#prod-datatype">datatype</a></span>)?</code></td>
</tr>
    <tr id="handle-RDFLiteral" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">            literal     </a></td><td></td><td>The literal has a lexical form of the first rule argument, <code>String</code>. If the <code>'^^' iri</code> rule matched, the datatype is <code>iri</code> and the literal has no language tag. If the <code>LANGTAG</code> rule matched, the datatype is <code>rdf:langString</code> and the language tag is <code>LANGTAG</code>. If neither matched, the datatype is <code>xsd:string</code> and the literal has no language tag.</td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-booleanLiteral">[<span class="prodNo">57</span>]¬†¬†¬†</td>
<td><code class="production prod">booleanLiteral</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"true" | "false"</code></td>
</tr>
    <tr id="handle-BooleanLiteral" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">            literal     </a></td><td></td><td>The literal has a lexical form of the <code>true</code> or <code>false</code>, depending on which matched the input, and a datatype of <code>xsd:boolean</code>.</td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-string">[<span class="prodNo">58</span>]¬†¬†¬†</td>
<td><code class="production prod">string</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content"><span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL1">STRING_LITERAL1</a></span> | <span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></span><br/>
| <span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL2">STRING_LITERAL2</a></span> | <span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-iri">[<span class="prodNo">59</span>]¬†¬†¬†</td>
<td><code class="production prod">iri</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-IRIREF">IRIREF</a></span> | <span class="prod"><a class="grammarRef" href="#prod-prefixedName">prefixedName</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-prefixedName">[<span class="prodNo">60</span>]¬†¬†¬†</td>
<td><code class="production prod">prefixedName</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PNAME_LN">PNAME_LN</a></span> | <span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td id="prod-blankNode">[<span class="prodNo">61</span>]¬†¬†¬†</td>
<td><code class="production prod">blankNode</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-BLANK_NODE_LABEL">BLANK_NODE_LABEL</a></span></code></td>
</tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td colspan="4">
    <h3 id="terminals">Terminals</h3>
    <p>
      Terminals return:
    </p>
    <ul>
      <li>the RDF abstract types <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri" class="math">IRI</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-lexical-form">lexical form</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">literal</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-language-tag">language tag</a>.</li>
      <li>a string of unicode codepoints for <a href="#term-CODE">CODE</a>.</li>
      <li>a <code>repeat range</code> for <a href="#term-REPEAT_RANGE">REPEAT_RANGE</a>. A <code>repeat range</code> is a tuple of non-negative integers or a non-negative integer and a token for <code>Unbounded</code>.</li>
    </ul>
  </td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-CODE">[<span class="prodNo">65</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">CODE</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"{" ([^%\\] | "\\" [%\\] | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* "%" "}"</code></td>
</tr>
    <tr id="handle-IRIREF" class="params"><td></td><td>returns: a string of unicode codepoints</td><td></td><td>The characters between "%" and "%}" are taken, with the <a href="http://www.w3.org/TR/2014/REC-turtle-20140225/#numeric">numeric escape sequences</a> unescaped, to form the unicode string of the IRI.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-REPEAT_RANGE">[<span class="prodNo">66</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">REPEAT_RANGE</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"{" <span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span> ( "," (<span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span> | "*")? )? "}"</code></td>
</tr>
    <tr id="handle-IRIREF" class="params"><td></td><td>returns: repeat range</td><td></td><td>The base-10 numeric values of <span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span> are taken or a non-negative integer and an <code>Unbounded</code> token if "<code>*</code>" was matched.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-RDF_TYPE">[<span class="prodNo">67</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">RDF_TYPE</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"a"</code></td>
</tr>
    <tr id="handle-PNAME_NS2" class="params"><td></td><td> returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri">      IRI </a></td><td></td><td>The <code>iri</code> <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code> is returned.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-IRIREF">[<span class="prodNo">68</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">IRIREF</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"&lt;" ([^#0000- &lt;&gt;\"{}|^`\\] | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* "&gt;"</code></td>
</tr>
    <tr id="handle-IRIREF" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri" class="math">IRI</a></td><td></td><td>The characters between "&lt;" and "&gt;" are taken, with the <a href="http://www.w3.org/TR/2014/REC-turtle-20140225/#numeric">numeric escape sequences</a> unescaped, to form the unicode string of the IRI. Relative IRI resolution is performed per Turtle <a class="sectionRef" href="http://www.w3.org/TR/2014/REC-turtle-20140225/#sec-iri-references">Section 6.3</a>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-PNAME_NS">[<span class="prodNo">69</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">PNAME_NS</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_PREFIX">PN_PREFIX</a></span>? ":"</code></td>
</tr>
    <tr id="handle-PNAME_NS" class="params"><td></td><td>returns: <a href="#dfn-Schema">                                 PREFIX      </a></td><td></td><td>When used in a <a href="#prod-prefixDecl">prefixDecl</a> production, the <code>prefix</code> is a potentially empty unicode string matching the first argument of the rule and serves as a key into the <a href="#dfn-Schema">prefixes map</a>.</td></tr>
    <tr id="handle-PNAME_NS2" class="params"><td></td><td> returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri">      IRI </a></td><td></td><td>When used elsewhere, the <code>iri</code> is the value in the <a href="#dfn-Schema">prefixes map</a> corresponding to the first argument of the rule.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-PNAME_LN">[<span class="prodNo">70</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">PNAME_LN</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span> <span class="prod"><a class="grammarRef" href="#term-PN_LOCAL">PN_LOCAL</a></span></code></td>
</tr>
    <tr id="handle-PNAME_LN" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri">      IRI         </a></td><td></td><td>A potentially empty <a href="#dfn-Schema">prefix</a> is identified by the first token, <code>PNAME_NS</code>. The <a href="#dfn-Schema">prefixes map</a> <em class="rfc2119"><em class="rfc2119" title="MUST">MUST</em></em> have a corresponding <code>namespace</code>. The unicode string of the IRI is formed by unescaping the <a href="#reserved">reserved characters</a> in the second argument, <code>PN_LOCAL</code>, and concatenating this onto the <code>namespace</code>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-ATPNAME_NS">[<span class="prodNo">71</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">ATPNAME_NS</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"@" <span class="prod"><a class="grammarRef" href="#term-PN_PREFIX">PN_PREFIX</a></span>? ":"</code></td>
</tr>
    <tr id="handle-PNAME_NS2" class="params"><td></td><td> returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri">      IRI </a></td><td></td><td>The <code>iri</code> is the value in the <a href="#dfn-Schema">prefixes map</a> corresponding to the second token of the rule.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-ATPNAME_LN">[<span class="prodNo">72</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">ATPNAME_LN</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"@" <span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span> <span class="prod"><a class="grammarRef" href="#term-PN_LOCAL">PN_LOCAL</a></span></code></td>
</tr>
    <tr id="handle-PNAME_LN" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri">      IRI         </a></td><td></td><td>A potentially empty <a href="#dfn-Schema">prefix</a> is identified by the second token, <code>PNAME_NS</code>. The <a href="#dfn-Schema">prefixes map</a> <em class="rfc2119"><em class="rfc2119" title="MUST">MUST</em></em> have a corresponding <code>namespace</code>. The unicode string of the IRI is formed by unescaping the <a href="#reserved">reserved characters</a> in the third token, <code>PN_LOCAL</code>, and concatenating this onto the <code>namespace</code>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-BLANK_NODE_LABEL">[<span class="prodNo">73</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">BLANK_NODE_LABEL</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"_:" (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS_U">PN_CHARS_U</a></span> | [0-9]) ((<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | ".")* <span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span>)?</code></td>
</tr>
    <tr id="handle-LANGTAG" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#blank-node">BNode</a></td><td></td><td>The characters following the "<code>_:</code>" form a blank node label. This corresponds to any blank node in the input dataset that had the same label.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-LANGTAG">[<span class="prodNo">74</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">LANGTAG</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*</code></td>
</tr>
    <tr id="handle-LANGTAG" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-language-tag">language tag</a></td><td></td><td>The characters following the <code>@</code> form the unicode string of the language tag.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-INTEGER">[<span class="prodNo">75</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">INTEGER</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">[+-]? [0-9]+</code></td>
</tr>
    <tr id="handle-INTEGER" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">            literal     </a></td><td></td><td>The literal has a lexical form of the input string, and a datatype of <code>xsd:integer</code>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-DECIMAL">[<span class="prodNo">76</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">DECIMAL</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">[+-]? [0-9]* "." [0-9]+</code></td>
</tr>
    <tr id="handle-DOUBLE" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">            literal     </a></td><td></td><td>The literal has a lexical form of the input string, and a datatype of <code>xsd:double</code>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-DOUBLE">[<span class="prodNo">77</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">DOUBLE</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">[+-]? ([0-9]+ "." [0-9]* <span class="prod"><a class="grammarRef" href="#term-EXPONENT">EXPONENT</a></span> | "."? [0-9]+ <span class="prod"><a class="grammarRef" href="#term-EXPONENT">EXPONENT</a></span>)</code></td>
</tr>
    <tr id="handle-DOUBLE" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">            literal     </a></td><td></td><td>The literal has a lexical form of the input string, and a datatype of <code>xsd:double</code>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-EXPONENT">[<span class="prodNo">78</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">EXPONENT</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">[eE] [+-]? [0-9]+</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-STRING_LITERAL1">[<span class="prodNo">79</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">STRING_LITERAL1</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"'" ([^'\\\n\r] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* "'"</code></td>
</tr>
    <tr id="handle-STRING_LITERAL1" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-lexical-form">                         lexical form</a></td><td></td><td>The characters between the outermost "'"s   are taken, with <a href="#numeric">numeric</a> and <a href="#string">string</a> escape sequences unescaped, to form the unicode string of a lexical form.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-STRING_LITERAL2">[<span class="prodNo">80</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">STRING_LITERAL2</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">'"' ([^\"\\\n\r] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* '"'</code></td>
</tr>
    <tr id="handle-STRING_LITERAL2" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-lexical-form">                         lexical form</a></td><td></td><td>The characters between the outermost '"'s   are taken, with <a href="#numeric">numeric</a> and <a href="#string">string</a> escape sequences unescaped, to form the unicode string of a lexical form.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-STRING_LITERAL_LONG1">[<span class="prodNo">81</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">STRING_LITERAL_LONG1</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"'''" ( ("'" | "''")? ([^\\'\\] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>) )* "'''"</code></td>
</tr>
    <tr id="handle-STRING_LITERAL_LONG1" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-lexical-form">                         lexical form</a></td><td></td><td>The characters between the outermost "'''"s are taken, with <a href="#numeric">numeric</a> and <a href="#string">string</a> escape sequences unescaped, to form the unicode string of a lexical form.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-STRING_LITERAL_LONG2">[<span class="prodNo">83</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">STRING_LITERAL_LONG2</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">'"""' ( ('"' | '""')? ([^\"\\] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>) )* '"""'</code></td>
</tr>
    <tr id="handle-STRING_LITERAL_LONG2" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-lexical-form">                         lexical form</a></td><td></td><td>The characters between the outermost '"""'s are taken, with <a href="#numeric">numeric</a> and <a href="#string">string</a> escape sequences unescaped, to form the unicode string of a lexical form.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-UCHAR">[<span class="prodNo">85</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">UCHAR</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content">"\\u" <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span><br/>
| "\\U" <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-ECHAR">[<span class="prodNo">86</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">ECHAR</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"\\" [tbnrf\\\"\\']</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-PN_CHARS_BASE">[<span class="prodNo">89</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">PN_CHARS_BASE</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content">[A-Z] | [a-z]<br/>
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]<br/>
| [#0370-#037D] | [#037F-#1FFF]<br/>
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]<br/>
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]<br/>
| [#10000-#EFFFF]</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-PN_CHARS_U">[<span class="prodNo">90</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">PN_CHARS_U</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_CHARS_BASE">PN_CHARS_BASE</a></span> | "_"</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-PN_CHARS">[<span class="prodNo">91</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">PN_CHARS</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_CHARS_U">PN_CHARS_U</a></span> | "-" | [0-9]<br/>
| [#00B7] | [#0300-#036F] | [#203F-#2040]</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-PN_PREFIX">[<span class="prodNo">92</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">PN_PREFIX</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_CHARS_BASE">PN_CHARS_BASE</a></span> ( (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | ".")* <span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> )?</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-PN_LOCAL">[<span class="prodNo">93</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">PN_LOCAL</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">(<span class="prod"><a class="grammarRef" href="#term-PN_CHARS_U">PN_CHARS_U</a></span> | ":" | [0-9] | <span class="prod"><a class="grammarRef" href="#term-PLX">PLX</a></span>) ( (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | "." | ":" | <span class="prod"><a class="grammarRef" href="#term-PLX">PLX</a></span>)* (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | ":" | <span class="prod"><a class="grammarRef" href="#term-PLX">PLX</a></span>) )?</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-PLX">[<span class="prodNo">94</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">PLX</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PERCENT">PERCENT</a></span> | <span class="prod"><a class="grammarRef" href="#term-PN_LOCAL_ESC">PN_LOCAL_ESC</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-PERCENT">[<span class="prodNo">95</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">PERCENT</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"%" <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-HEX">[<span class="prodNo">96</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">HEX</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">[0-9] | [A-F] | [a-f]</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-PN_LOCAL_ESC">[<span class="prodNo">97</span>]¬†¬†¬†</td>
<td>&lt;<code class="production term">PN_LOCAL_ESC</code>&gt;</td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td><code class="content">"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&amp;" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td id="term-PASSED_TOKENS">[<span class="prodNo">98</span>]¬†¬†¬†</td>
<td><code class="production directive">PASSED TOKENS</code></td>
<td>¬†¬†¬†::=¬†¬†¬†</td>
<td>¬†¬†¬†<code class="content">[ \t\r\n]+<br/>
| "#" [^\r\n]*</code></td>
</tr>
</tbody>

</table>
      </div>

      <div class="example">
  <div class="with-highlight">
    <p>
      Moving the mouse over the elements of the list below will highlight the corresponding elements in the triple expression.
    </p>
      <ul>
        <li><span class="hl-tc lowlight1">triple constraint</span> (<as><a href="#dfn-TripleConstraint">TripleConstraint</a></as>)</li>
        <li><span class="hl-oneof lowlight2">one-of triple expression</span> (<as><a href="#dfn-OneOfTripleExpr">OneOfTripleExpr</a></as>)</li>
        <li><span class="hl-eachof lowlight2">each-of triple expression</span> (<as><a href="#dfn-EachOfTripleExpr">EachOfTripleExpr</a></as>)</li>
        <li><span class="hl-repet lowlight3">repeated triple expression</span> (<as><a href="#dfn-RepeatedTripleExpr">RepeatedTripleExpr</a></as>)</li>
        <li><span class="hl-inverse-tc lowlight1">triple constraint with an inverse property</span></li>
        <!-- li><span class="hl-tc-cofinite lowlight1">triple constraint with a non-singleton co-finite set of properties</span></li -->
        <li><span class="hl-shref lowlight4">shape reference</span> (<as><a href="#dfn-ShapeRef">ShapeRef</a></as>)</li>
      </ul>
<pre class="shex">
# triple expression of the shapes language

&lt;S1&gt; {

<span class="hl-eachof lowlight2">  <span class="hl-tc lowlight1">rdf:type <span class="hl-shref lowlight4">@&lt;SL_1&gt;</span></span> ;

  <span class="hl-tc lowlight1">foaf:name <span class="hl-shref lowlight4">@&lt;SL_2&gt;</span></span> ;

  <span class="hl-oneof lowlight2">( <span class="hl-repet lowlight3"><span class="hl-tc lowlight1">foaf:mbox <span class="hl-shref lowlight4">@&lt;SL_3&gt;</span></span> {1,3}</span> | <span class="hl-tc lowlight1">foaf:adress <span class="hl-shref lowlight4">@&lt;SL_3&gt;</span></span> )</span> ;

  <span class="hl-tc hl-inverse-tc lowlight1">^ex:leader &lt;SL_4&gt;</span> ;
<!--
  <span class="hl-repet lowlight3"><span class="hl-tc hl-tc-cofinite lowlight1">C{rdf:type, foaf:name, foaf:givenName, foaf:familyName, foaf:mbox, ^ex:leader} <span class="hl-shref lowlight4">@&lt;SL_all&gt;</span></span> *</span>
--></span>}
</pre>
    <!-- p>
      Where <span class="pre">C{rdf:type, foaf:name, foaf:givenName, foaf:familyName, foaf:mbox} = (Prop ‚à™ InvProp) \ {rdf:type, foaf:name, foaf:givenName, foaf:familyName, foaf:mbox}</span>, that is, the complement of the set <span class="pre">{rdf:type, foaf:name, foaf:givenName, foaf:familyName, foaf:mbox}</span> within the set of all properties and inverse properties.
    </p -->
  </div>
  <script type="text/javascript">
    <!--
        prepareHighlight(["hl-tc", "hl-tc-cofinite", "hl-inverse-tc"], "highlight1", "lowlight1");
        prepareHighlight(["hl-oneof", "hl-eachof"], "highlight2", "lowlight2");
        prepareHighlight(["hl-repet"], "highlight3", "lowlight3");
        prepareHighlight(["hl-shref"], "highlight4", "lowlight4");
      -->
  </script>
      </div>
      
    <section id="compilation-example">
      <h3>Examples of Compilating ShExC into ShExJ</h3>
      <!-- @@Labra: I didn't quite understand what is the point of this section...is this obsolete? -->
      <!-- @@ericP: yes, needs review for salvagable bits -->
  
  <section id="compilation-example-closed-shape">
    <h4>Closed shape expression</h4>
    
    <div class="example">
      <div class="with-highlight">
        <p>
    Every <span class="hl-issueshape hl-usershape lowlight2">shape label</span> from the ShEx schema is used as <span class="hl-issueshape lowlight2">shape label</span> in the shapes schema, which definition is the compilation of the definition from the ShEx schema.
        </p>
        <p>
    Every <span class="hl-ve1 hl-ve3 lowlight1">shape expression</span> that appears in a triple constraint of the ShEx schema yields a <span class="hl-ve1  hl-ve2 hl-ve3 hl-ve4 hl-ve4bis">fresh shape label having the same definition</span> in the shapes schema.
    This does not apply to shape expressions that are references.
        </p>
        <p>
    The translation of a CLOSED <span class="hl-te lowlight3">triple expression</span> in the ShEx schema translates almost directly to a <span class="hl-te lowlight3">triple expression</span> in the shapes schema, exept that predicates are replaced with singleton sets, and <span class="hl-ve1 hl-ve3 lowlight1">value expressions</span> are replaced with the corresponding freshly introduced <span class="hl-ve1 hl-ve3 lowlight1">shape labels</span> 
        </p>

<pre class="shex" style="float:left">
# ShEx schema

<span class="hl-issueshape lowlight2">&lt;IssueShape&gt;</span>
<div class="hl-te lowlight3">
CLOSED {                 
    ex:state      <span class="hl-ve1 lowlight1">[ex:unassigned ex:assigned]</span> ; 
    ex:reportedBy @&lt;UserShape&gt; ;   
    ex:reportedOn <span class="hl-ve3 lowlight1">xsd:dateTime OR xsd:date</span> ;
    ex:related    @&lt;IssueShape&gt;* ;
    ^ex:related   @&lt;IssueShape&gt;*
}</div>
<span class="hl-usershape lowlight2">&lt;UserShape&gt;</span> {
    a PATTERN "http://example.org/User#.*"
}
</pre>
<pre class="shex" style="float:left">
# shapes schema

<span class="hl-issueshape lowlight2">&lt;IssueShape&gt; </span>:= 
<div class="hl-te lowlight3">{
    {ex:state}      <span class="hl-ve1 lowlight1">&lt;SL_1&gt;</span> ;
    {ex:reportedBy} &lt;UserShape&gt;
    {ex:reportedOn} <span class="hl-ve3 lowlight1">&lt;SL_3&gt;</span> ;
    {ex:related}    &lt;IssueShape&gt;*  ;
    {^ex:related}   &lt;IssueShape&gt;*
}
</div>

<span class="hl-usershape lowlight2">&lt;UserShape&gt;</span> {
    Set(PATTERN "http://example.org/User#.*")
}


<span class="hl-ve1 lowlight1">&lt;SL_1&gt;  := {ex:unassigned, ex:assigned}</span>
<span class="hl-ve3 lowlight1">&lt;SL_3&gt;  := xsd:dateTime OR xsd:date</span>
</pre>

      </div>
      <script type="text/javascript">
        <!--
      prepareHighlight(["hl-ve1", "hl-ve3" ], "highlight1", "lowlight1");
      prepareHighlight(["hl-issueshape", "hl-usershape"], "highlight2", "lowlight2");
      prepareHighlight(["hl-te"], "highlight3", "lowlight3");
    -->
      </script>
      <div style="clear:both;"> </div>
    </div>    
  </section>

      <section id="translate-example-closed-with-extra">
  <h4>Closed shape expression with EXTRA modifier</h4>

  <div class="example">
    <div class="with-highlight">
      <p>
        As in the previous example, the value expressions of the ShEx schema yield shape labels with the same definition. Here, the resulting fresh shape labels are <span class="pre">&lt;SL_5&gt;, &lt;SL_6&gt;, &lt;SL_7&gt;, &lt;SL_8&gt;</span>.
      </p>
      <p>
        The <span class="hl-shapexpr lowlight3">triple expression</span> from the ShEx schema is translated into a <span class="hl-shapexpr lowlight3">triple expression</span> in the shapes schema.
        <span class="hl-samete lowlight1">One part of that triple expression</span> is a direct translation of <span class="hl-samete lowlight1">the triple expression from the ShEx schema</span>.
      </p>
      <p>
        The <span class="hl-extra lowlight1">EXTRA modifier</span> results in <span class="hl-extra lowlight1">additional triple constraints</span> in the shapes schema. 
        There is one such triple constraint with * cardinality for every extra property. 
        For every extra property, the <span class="hl-extra-ve1 hl-extra-ve2 lowlight2">value expression is the negation of the value expressions that occur with the same property</span>.
      </p>

<pre class="shex" style="float:left">
# ShEx schema
        
        
        






&lt;UserShape&gt;
<div class="hl-shapexpr lowlight3">CLOSED 
<span class="hl-extra">EXTRA rdf:type foaf:mbox</span> {
<div class="hl-samete lowlight4">
    rdf:type <span class="hl-extra-ve1 lowlight2">[foaf:Person]</span> ;
    rdf:type <span class="hl-extra-ve1 lowlight2">[ex:User]</span> ;
    (                                   
       foaf:name xsd:string 
     |                                  
       foaf:givenName xsd:string+ ;      
       foaf:familyName xsd:string
    );
    foaf:mbox <span class="hl-extra-ve2 lowlight2">IRI</span>
</div>
}
</div>
</pre>


<pre class="shex" style="float:left">
# shapes schema

&lt;SL_5&gt; := {foaf:Person}
&lt;SL_6&gt; := {ex:User}
&lt;SL_7&gt; := xsd:string
&lt;SL_8&gt; := IRI

&lt;SL_UserShape_Extra_rdftype&gt; := <span class="hl-extra-ve1 lowlight2">NOT{foaf:Person} AND NOT{ex:User}</span>
&lt;SL_UserShape_Extra_foafmxbox&gt; := <span class="hl-extra-ve2 lowlight2">NOT IRI</span>


&lt;UserShape&gt; := 
<div class="hl-shapexpr lowlight3">{
<div class="hl-samete lowlight4">    {rdf:type}  &lt;SL_5&gt; ;
    {rdf:type}  &lt;SL_6&gt; ;
    (
        {foaf:name}       &lt;SL_7&gt;
    |
        {foaf:givenName}  &lt;SL_7&gt;+ ;
        {foaf:familyName} &lt;SL_7&gt;
    );
    {foaf:mbox} &lt;SL_8&gt; ;
</div>
<div class="hl-extra lowlight1">    {rdf:type}  <span class="hl-extra-ve1 lowlight2">&lt;SL_UserShape_Extra_rdftype&gt;</span> * ;
    {foaf:mbox} <span class="hl-extra-ve2 lowlight2">&lt;SL_UserShape_Extra_foafmbox&gt;</span> * ;
</div>
}
</div>
</pre>
<div style="clear:both;"> </div>

    </div>  
  </div>
  <script type="text/javascript">
    <!--
        prepareHighlight(["hl-extra"], "highlight1", "lowlight1");
        prepareHighlight(["hl-extra-ve1", "hl-extra-ve2"], "highlight2", "lowlight2");
        prepareHighlight(["hl-shapexpr"], "highlight3", "lowlight3");
        prepareHighlight(["hl-samete"], "highlight4", "lowlight4");
      -->
  </script>
      </section>

      <section id="compilation-example-non-closed-shape">
  <h4>Non closed shape expression</h4>
  <div class="example">
    <div class="with-highlight">
      <p>
        As for the case with EXTRA properties, the <span class="hl-shapexpr lowlight3">shape expression</span> from the ShEx schema is tranlated into a <span class="hl-shapexpr lowlight3">triple expression</span> with an <span class="hl-open-tc lowlight4">additional triple constraint with * cardinality</span>.
        The <span class="hl-propset lowlight2">set of properties</span> of the latter is the set of <span class="hl-propset lowlight2">all properties that do not appear in the shape expression</span>. 
        The <span class="hl-ve lowlight1">value expression</span> accepts all values.
      </p>
      
      
<pre class="shex" style="float:left">
# ShEx schema





&lt;SomeShape&gt; 
<div class="hl-shapexpr lowlight3">{
    ex:p xsd:int* ;
    ( ex:q xsd:int | ex:r IRI )? 
}
</div>
</pre>
<pre class="shex" style="float:left">
# shapes schema

&lt;SL_9&gt;  := xsd:int
&lt;SL_10&gt; := IRI

<span class="hl-ve lowlight1">&lt;SL_all_values&gt;  := IRI ‚à™ Literal ‚à™ {blank}</span>

&lt;SomeShape&gt; := 
<div class="hl-shapexpr lowlight3">{
    {ex:p}  &lt;SL_9&gt;* ;
    ( {ex:q}  &lt;SL_9&gt; | {ex:r} &lt;SL_10&gt; )? ;

<span class="hl-open-tc lowlight4">    <span class="hl-propset lowlight2">PropSet</span>  <span class="hl-ve lowlight1">&lt;SL_all_values&gt;</span>*    </span>
}
</div>

# with <span class="hl-propset lowlight2">PropSet = (Prop ‚à™ InvProp) \ {ex:p, ex:q, ex:r}</span>
</pre>
<div style="clear:both;"> </div>

    </div>
    <script type="text/javascript">
      <!--
    prepareHighlight(["hl-ve"], "highlight1", "lowlight1");
    prepareHighlight(["hl-propset"], "highlight2", "lowlight2");
    prepareHighlight(["hl-shapexpr"], "highlight3", "lowlight3");
    prepareHighlight(["hl-open-tc"], "highlight4", "lowlight4");
        -->
    </script>
  </div>
      </section>

      <section id="compilation-example-conjunctive-shape">
  <h4>Complex shape definition</h4>

  <div class="example">
    <div class="with-highlight">
      <p>
        The shape label <span class="pre">&lt;EmployeeShape&gt;</span> is defined as a conjunction of <span class="hl-nc lowlight2">node constrints</span> and <span class="hl-te1 hl-te2 lowlight3">triple expressions</span>.
        In the shapes schema, this yields a <span class="hl-conj lowlight4"><a href="#dfn-ShapeAnd">ShapeAnd</a> shape expression</span> with one conjunct per conjunct in the ShEx schema.
      </p>
      
<pre class="shex" style="float:left">
# ShEx schema

&lt;EmployeeShape&gt;
<span class="hl-nc lowlight2">PATTERN "^http:/example.org/.*"</span>

<div class="hl-te1 lowlight3">CLOSED {        
    foaf:phone IRI*;          
    foaf:mbox IRI             
}
</div>
AND 

<div class="hl-te2 lowlight3">CLOSED {
    ( foaf:phone PATTERN "^tel:\\+33" ; 
      foaf:mbox  PATTERN "\\.fr$" )?   ;
    ( foaf:phone PATTERN "^tel:\\+44" ; 
      foaf:mbox  PATTERN "\\.uk$")?
}
</div>
</pre>

<pre class="shex" style="float:left">
# shapes schema

&lt;SL_11&gt; := Set(PATTERN "^tel:\\+33")
&lt;SL_12&gt; := Set(PATTERN "\\.fr$")
&lt;SL_13&gt; := Set(PATTERN "^tel:\\+44")
&lt;SL_14&gt; := Set(PATTERN "\\.uk$")
&lt;SL_15&gt; := IRI

&lt;EmployeeShape&gt; := {<div class="hl-conj lowlight4">
    <span class="hl-nc lowlight2">Set(PATTERN "^http:/example.org/.*")</span>

    AND 
<div class="hl-te1 lowlight3">
    {foaf:phone} &lt;SL_15&gt;* ;
    {foaf:mbox}  &lt;SL_15&gt;
</div>
    AND 
<div class="hl-te2 lowlight3">
    ( {foaf:phone} &lt;SL_11&gt; ;
      {foaf:mbox}  &lt;SL_12&gt; )? ;
    ( {foaf:phone} &lt;SL_13&gt; ;
      {foaf:mbox}  &lt;SL_14&gt; )?
</div>
}
</div>
</pre>
<div style="clear:both;"> </div>

    </div>
    <script type="text/javascript">
      <!--
    prepareHighlight([], "highlight1", "lowlight1");
    prepareHighlight(["hl-nc"], "highlight2", "lowlight2");
    prepareHighlight(["hl-te1", "hl-te2"], "highlight3", "lowlight3");
    prepareHighlight(["hl-conj"], "highlight4", "lowlight4");
        -->
    </script>
  </div>
      </section>

      <section id="compilation-example-negated-triple-constraint">
  <h4>Negated triple expression</h4>
  <div class="example">
    <div class="with-highlight">

      <p>
        The <span class="hl-negte lowlight4">negated triple constraint</span> is treated as if <span class="hl-prop lowlight2">its property</span> was an <span class="hl-prop lowlight2">extra property</span>.
        The corresponding <span class="hl-negte lowlight4">triple constraint in the translation</span> has a <span class="hl-zerocard lowlight3">{0,0} cardinality</span>.
      </p>

<pre class="shex" style="float:left">
# ShEx schema

&lt;SomeShape&gt; 
CLOSED {
    ex:p xsd:int* ;
    (<span class="hl-negte lowlight4"> <span class="hl-prop lowlight2">ex:q</span> xsd:int {0,0} </span> 
      | ex:r IRI )? 
}
</pre>
<pre class="shex" style="float:left">
# shapes schema

&lt;SL_9&gt;  := xsd:int
&lt;SL_10&gt; := IRI
&lt;SL_Extra&gt; := NOT xsd:int

&lt;SomeShape&gt; := { 
    {ex:p}  &lt;SL_9&gt;* ;
    (<span class="hl-negte lowlight4"> {ex:q}  &lt;SL_9&gt;<span class="hl-zerocard lowlight3">{0,0}</span> </span>
      | {ex:r} &lt;SL_10&gt; )? ;

    <span class="hl-prop lowlight2">{ex:q}</span>  &lt;SL_Extra&gt;*
}

</pre>
<div style="clear:both;"></div>

    </div>
    <script type="text/javascript">
      <!--
    prepareHighlight([], "highlight1", "lowlight1");
    prepareHighlight(["hl-prop"], "highlight2", "lowlight2");
    prepareHighlight(["hl-zerocard"], "highlight3", "lowlight3");
    prepareHighlight(["hl-negte"], "highlight4", "lowlight4");
        -->
    </script>
  </div>
      </section>
    </section>
    </section>

  </body>
</html>
